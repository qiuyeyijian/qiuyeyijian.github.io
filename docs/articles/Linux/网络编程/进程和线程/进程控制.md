# 进程控制

## 进程概述

从严格意义上来讲，程序和进程是两个不同的概念，他们的状态，占用的系统资源都是不同的。

程序：就是磁盘上的可执行文件文件，并且只占用磁盘上的空间，是一个静态的概念。

进程：被执行之后的程序叫做进程，不占用磁盘空间，需要消耗系统的内存，CPU资源，每个运行的进程的都对应一个属于自己的虚拟地址空间，这是一个动态的概念。



### 并行和并发

CPU 在某个时间点只能处理一个任务，但是操作系统都支持多任务的，那么在计算机 CPU 只有一个和的情况下是怎么完成多任务处理的呢？原理和古时候救济灾民的思路是一样的，每个人分一点，但是又不叫吃饱。

CPU 会给每个进程被分配一个时间段，进程得到这个时间片之后才可以运行，使各个程序从表面上看是同时进行的。如果在时间片结束时进程还在运行，CPU 的使用权将被收回，该进程将会被中断挂起等待下一个时间片。如果进程在时间片结束前阻塞或结束，则 CPU 当即进行切换，这样就可以避免 CPU 资源的浪费。

因此可以得知，在我们使用的计算机中启动的多个程序，从宏观上看是同时运行的，从微观上看由于 CPU 一次只能处理一个进程，所有它们是轮流执行的，只不过切换速度太快，我们感觉不到罢了，因此 CPU 的核数越多计算机的处理效率越高。

**并发**：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。并发的同时运行是一个假象。是针对某一个硬件资源而言的，在某个时间段之内处理的任务的总量，量越大效率越高。

**并行**：指两个或多个时间在同一时刻同时发生。并行的多进程同时运行是真实存在的，可以在同一时刻同时运行多个进程。并行需要依赖多个硬件资源，单个是无法实现的



### PCB

PCB - 进程控制块（Processing Control Block），Linux 内核的进程控制块本质上是一个叫做 `task_struct` 的结构体。在这个结构体中记录了进程运行相关的一些信息，下面介绍一些常用的信息：

- 进程 id：每一个进程都一个唯一的进程 ID，类型为 `pid_t`, 本质是一个整形数

- 进程的状态：进程有不同的状态，状态是一直在变化的，有就绪、运行、挂起、停止等状态。

- 进程对应的虚拟地址空间的信息。

- 描述控制终端的信息，进程在哪个终端启动默认就和哪个终端绑定。

- 当前工作目录：默认情况下，启动进程的目录就是当前的工作目录

- `umask `掩码：在创建新文件的时候，通过这个掩码屏蔽某些用于对文件的操作权限。
- 文件描述符表：每个被分配的文件描述符都对应一个已经打开的磁盘文件

- 和信号相关的信息：在 Linux 中 调用函数 , 键盘快捷键 , 执行shell命令等操作都会产生信号。

- 阻塞信号集：记录当前进程中阻塞哪些已产生的信号，使其不能被处理
  未决信号集：记录在当前进程中产生的哪些信号还没有被处理掉。
- 用户 id 和组 id：当前进程属于哪个用户，属于哪个用户组

- 会话（Session）和进程组：多个进程的集合叫进程组，多个进程组的集合叫会话。

- 进程可以使用的资源上限：可以使用 shell 命令 `ulimit -a `查看详细信息。




### 进程状态

进程一共有五种状态分别为：创建态，就绪态，运行态，阻塞态(挂起态)，退出态(终止态) 其中创建态和退出态维持的时间是非常短的，稍纵即逝。

![img](assets/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/1557237111672.png)



就绪态：万事俱备，只欠东风（CPU资源）

- 进程被创建出来了，有运行的资格但是还没有运行，需要抢 CPU 时间片
- 得到 CPU 时间片，进程开始运行，从就绪态转换为运行态。
- 进程的 CPU 时间片用完了，再次失去 CPU, 从运行态转换为就绪态。

运行态：获取到 CPU 资源的进程，进程只有在这种状态下才能运行

- 运行态不会一直持续，进程的 CPU 时间片用完之后，再次失去 CPU，从运行态转换为就绪态
- 只要进程还没有退出，就会在就绪态和运行态之间不停的切换。

阻塞态：进程被强制放弃 CPU，并且没有抢夺 CPU 时间片的资格

- 比如：在程序中调用了某些函数（比如: `sleep ()`），进程又运行态转换为阻塞态（挂起态）
- 当某些条件被满足了（比如：`slee () `睡醒了），进程的阻塞状态也就被解除了，进程从阻塞态转换为就绪态。

退出态：进程被销毁，占用的系统资源被释放了

- 任何状态的进程都可以直接转换为退出态。



### 进程命令

```bash
ps -aux		# 查看进程信息
```

`kill` 命令可以发送某个信号到对应的进程，进程收到某些信号之后默认的处理动作就是退出进程，如果要给进程发送信号，可以先查看一下 Linux 给我们提供了哪些标准信号。

```bash
kill -l

1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
...
```

9 号信号（SIGKILL）的行为是无条件杀死进程，想要杀死哪个进程就可以把这个信号发送给这个进程

```bash
# 无条件杀死进程, 进程ID通过 ps aux 可以查看
$ kill -9 进程ID
$ kill -SIGKILL 进程ID
```



## 进程创建

Linux 中进程 ID 为` pid_t `类型，其本质是一个正整数，通过上边的` ps aux` 命令已经得到了验证。PID 为 1 的进程是 Linux 系统中创建的第一个进程。

```cpp
#include <sys/types.h>
#include <unistd.h>
pid_t getpid(void);		// 获取当前进程的进程 ID（PID）
pid_t getppid(void);	//获取当前进程的父进程 ID（PPID）
pid_t fork(void);
```

> Linux 中看似创建一个新的进程非常简单，函数连参数都没有，实际上如果想要真正理解这个函数还是得死几个脑细胞。

### fork()

启动磁盘上的应用程序，得到一个进程，如果在这个启动的进程中调用 fork() 函数，就会得到一个新的进程，我们习惯将其称之为子进程。前面说过每个进程都对应一个属于自己的虚拟地址空间，子进程的地址空间是基于父进程的地址空间拷贝出来的，虽然是拷贝但是两个地址空间中存储的信息不可能是完全相同的，下图是拷贝之后父子进程各自的虚拟地址空间：

![img](assets/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/image-20210203181255536.png)



### 父子进程相同点

拷贝完成之后（注意这个时间点），两个地址空间中的用户区数据是相同的。用户区数据主要数据包括：

- 代码区：默认情况下父子进程地址空间中的源代码始终相同。
- 全局数据区：父进程中的全局变量和变量值全部被拷贝一份放到了子进程地址空间中
- 堆区：父进程中的堆区变量和变量值全部被拷贝一份放到了子进程地址空间中
- 动态库加载区（内存映射区）：父进程中数据信息被拷贝一份放到了子进程地址空间中
- 栈区：父进程中的栈区变量和变量值全部被拷贝一份放到了子进程地址空间中
- 环境变量：默认情况下，父子进程地址空间中的环境变量始终相同。
- 文件描述符表: 父进程中被分配的文件描述符都会拷贝到子进程中，在子进程中可以使用它们打开对应的文件。

### 父子进程区别

父子进程各自的虚拟地址空间是相互独立的，不会互相干扰和影响。

父子进程地址空间中代码区代码虽然相同，但是父子进程执行的代码逻辑可能是不同的。

由于父子进程可能执行不同的代码逻辑，因此地址空间拷贝完成之后，全局数据区 , 栈区 , 堆区 , 动态库加载区(内存映射区) 数据会各自发生变化，由于地址空间是相互独立的，因此不会互相覆盖数据。

由于每个进都有自己的进程 ID，因此内核区存储的父子进程 ID 是不同的。

进程启动之后进入就绪态，运行需要争抢 CPU 时间片而且可能执行不同的业务逻辑，所以父子进程的状态可能是不同的。

fork () 调用成功之后，会返回两个值，父子进程的返回值是不同的。

- 该函数调用成功之后，从一个虚拟地址空间变成了两个虚拟地址空间，每个地址空间中都会将 fork() 的返回值记录下来，这就是为什么会得到两个返回值的原因。

- **父进程的虚拟地址空间中将该返回值标记为一个大于 0 的数（其实记录的是子进程的进程 ID）**

- **子进程的虚拟地址空间中将该返回值标记 0**
- **在程序中需要通过 fork () 的返回值来判断当前进程是子进程还是父进程。**

```cpp
#include <unistd.h>

#include <cstdio>

int main() {
  // 在父进程中创建子进程
  pid_t pid = fork();

  if (pid > 0) {
    // 父进程的执行逻辑
    printf("Process of father, pid: %d\n", getpid());
  } else if (pid == 0) {
    // 子进程的执行逻辑
    printf("Porcess of son, pid: %d, ppid: %d\n", getpid(), getppid());
  } else {
    //创建子进程失败了
  }

  // 不加判断，父子进程都会执行这个循环
  printf("Hello!\n");

  return 0;
}
```



## 父子进程

### 进程执行位置

在父进程中成功创建了子进程，子进程就拥有父进程代码区的所有代码，那么子进程中的代码是在什么位置开始运行的呢？父进程肯定是从 main () 函数开始运行的，子进程是在父进程中调用 fork () 函数之后被创建，**子进程就从 fork () 之后开始向下执行代码。**

**可以看到如果在程序中对 fork() 的返回值做了判断，就可以控制父子进程的行为，**如果没有做任何判断这个代码块父子进程都可以执行。在编写多进程程序的时候，一定要将代码想象成多份进行分析，因为直观上看代码就一份，但实际上数据都是多份，并且多份数据中变量名都相同，但是他们的值却不一定相同。

### 循环创建子进程

```cpp
#include <unistd.h>

#include <cstdio>

int main() {
  for (int i = 0; i < 3; ++i) {
    pid_t pid = fork();
    printf("pid: %d\n", getpid());
  }

  return 0;
}
```

![img](assets/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/image-20191229121508802.png)



可以发现，最终创建得到了8个进程，一个父进程，七个子进程。我们们可以只让父进程创建子进程，如果是子进程不让其继续创建子进程，因此只需要在程序中添加关于父子进程的判断即可。

```cpp
int main() {
  for (int i = 0; i < 3; ++i) {
    pid_t pid = fork();
    if (pid == 0) {
      break;
    }
    printf("pid: %d\n", getpid());
  }

  return 0;
}
```

> 在多进程序中，进程的执行顺序是没有规律的，因为所有的进程都需要在就绪态争抢CPU时间片，抢到了就执行，抢不到就不执行，但是不用担心，默认进程的优先级是相同的，操作系统不会让某一个进程一直抢不到CPU时间片。
>



### 终端显示问题

在执行多进程程序的时候，经常会遇到下图中的问题，看似进程还没有执行完成，貌似是因为什么原因被阻塞了，实际上终端是正常的，当我们通过键盘输入一些命令，终端也能接受输入并且输出相关信息，那么为什么终端会显示成这个样子呢？

![img](assets/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/image-20210203215938828.png)

- 
  a.out 进程启动之后，共创建了 3 个子进程，其实 a.out 也是有父进程的就是当前的终端

- 终端只能检测到 a.out 进程的状态，a.out 执行期间终端切换到后台，a.out 执行完毕之后终端切换回前台

- 当终端切换到前之后，a.out 的子进程还没有执行完毕，当子进程输出的信息就显示到终端命令提示符的后边了，导致终端显示有问题，但是此时终端是可以接收键盘输入的，只是看起来不美观而已。

- 想要解决这个问题，需要让所有子进程退出之后再退出父进程，比如：在父进程代码中调用 sleep ()


```cpp
 pid_t pid = fork();
  if (pid > 0) {
    sleep(3);  // 让父进程睡一会儿
  } else if (pid == 0) {
    // 子进程
  }
```



### 进程数数

思考一个问题，当父进程创建一个子进程，那么父子进程之间可以通过全局变量互动，实现交替数数的功能吗？

```cpp
// 定义全局变量
int number = 10;

int main() {
  printf("Before creating son process, number: %d\n", number);

  pid_t pid = fork();
  // 父子进程都会执行这一行

  if (pid > 0) {
    printf("The father process, pid: %d, number: %d\n", getpid(), ++number);
    printf("The grandfather process, pid: %d\n", getpid());
    sleep(1);
  } else if (pid == 0) {
    number += 100;
    printf("The son process, pid: %d, number: %d\n", getpid(), number);
    printf("My father process, pid: %d\n", getppid());
  }

  return 0;
}
```

通过验证得到结论：**两个进程中是不能通过全局变量实现数据交互的，因为每个进程都有自己的地址空间**，两个同名全局变量存储在不同的虚拟地址空间中，二者没有任何关联性。如果要进行进程间通信需要使用：管道，共享内存，本地套接字，内存映射区，消息队列等方式。

通过验证得到结论：两个进程中是不能通过全局变量实现数据交互的，因为每个进程都有自己的地址空间，两个同名变量存储在不同的虚拟地址空间中，二者没有任何关联性。

## execl 和execlp函数

在项目开发过程中，有时候有这种需求，需要通过现在运行的进程启动磁盘上的另一个可执行程序，也就是通过一个进程启动另一个进程，这种情况下我们可以使用 exec族函数，函数原型如下：

```cpp
extern char **environ;
int execl(const char *path, const char *arg, ...
          /* (char  *) NULL */);
int execlp(const char *file, const char *arg, ...
           /* (char  *) NULL */);
int execle(const char *path, const char *arg, ...
           /*, (char *) NULL, char * const envp[] */);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[], char *const envp[]);
```

这些函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代（**也就是说用户区数据基本全部被替换掉了**），只留下进程 ID 等一些表面上的信息仍保持原样，颇有些神似” 三十六计” 中的” 金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回一个 -1，从原程序的调用点接着往下执行。

> 也就是说 exec族函数并没有创建新进程的能力，只是有大无畏的牺牲精神，让起启动的新进程寄生到自己虚拟地址空间之内，并挖空了自己的地址空间用户区，把新启动的进程数据填充进去。

exec族函数中最常用的有两个` execl() `和 `execlp()`，这两个函数是对其他 4 个函数做了进一步的封装，下面介绍一下。



### execl()

该函数可用于执行任意一个可执行程序，函数需要通过指定的文件路径才能找到这个可执行程序。

```cpp
#include <unistd.h>
// 变参函数
int execl(const char *path, const char *arg, ...);
```

- `path`： 要启动的可执行程序的路径，推荐使用绝对路径
- `arg`： ps aux 查看进程的时候，启动的进程的名字，可以随意指定，一般和要启动的可执行程序名相同
- `... `：要执行的命令需要的参数，可以写多个，最后以 NULL 结尾，表示参数指定完了。
- `返回值`：如果这个函数执行成功，没有返回值，如果执行失败，返回 -1



### execlp()

该函数常用于执行已经设置了环境变量的可执行程序，函数中的 p 就是 path，也是说这个函数会自动搜索系统的环境变量 PATH，**因此使用这个函数执行可执行程序不需要指定路径，只需要指定出名字即可。**

```cpp
// p == path
int execlp(const char *file, const char *arg, ...);
```

* `file`：可执行程序的名字。在环境变量 PATH 中，可执行程序可以不加路径。没有在环境变量 PATH 中，可执行程序需要指定绝对路径

- `arg`：ps aux 查看进程的时候，启动的进程的名字，可以随意指定，一般和要启动的可执行程序名相同
- `... `：要执行的命令需要的参数，可以写多个，最后以 NULL 结尾，表示参数指定完了。
- `返回值`：如果这个函数执行成功，没有返回值，如果执行失败，返回 -1



### 函数使用

关于 exec 族函数，我们一般不会在进程中直接调用，如果直接调用这个进程的代码区代码被替换也就不能按照原来的流程工作了。

**我们一般在调用这些函数的时候都会先创建一个子进程，在子进程中调用 exec 族函数**，子进程的用户区数据被替换掉开始执行新的程序中的代码逻辑，但是父进程不受任何影响仍然可以继续正常工作。

```cpp
int main() {
  // 创建子进程
  pid_t pid = fork();

  if (pid > 0) {
    printf("I am father process!\n");
  } else if (pid == 0) {
    // 磁盘上的可执行程序 /bin/ps
    execl("/bin/ps", "myps", "aux", NULL);

    /* 也可以这么写
    execl("/bin/ps", "myps", "a", "u", "x", NULL);
    execlp("ps", "myps", "aux", NULL);
    */

    // 如果成功当前子进程的代码区被替换，下面的所有代码都不会执行
    // 如果函数调用失败了,才会继续执行下面的代码
    perror("execl");
    printf("======error!!!======\n");
  }

  return 0;
}
```

`execl()/execlp`的第二个参数指定什么，进程的名字就显示什么，例如下面的`ps`进程被显示成`myps`

![image-20220325120707101](assets/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/image-20220325120707101.png)



## 进程控制

进程控制主要是指进程的退出 , 进程的回收和进程的特殊状态：孤儿进程和僵尸进程。



### 结束进程

如果想要直接退出某个进程可以在程序的任何位置调用 `exit()` 或者`_exit() `函数。函数的参数相当于退出码，如果参数值为 0 程序退出之后的状态码就是 0, 如果是 100 退出的状态码就是 100。

```cpp
// 专门退出进程的函数, 在任何位置调用都可以
// 标准C库函数
#include <stdlib.h>
void exit(int status);

// Linux的系统函数
// 可以这么理解, 在linux中 exit() 函数 封装了 _exit()
#include <unistd.h>
void _exit(int status);
```

在 main 函数中直接使用 return 也可以退出进程，假如是在一个普通函数中调用 return 只能返回到调用者的位置，而不能退出进程。



### 孤儿进程

在一个启动的进程中创建子进程，这时候父子进程同时运行，但是父进程由于某种原因先退出了，子进程还在运行，这时候这个子进程就可以被称之为孤儿进程（跟现实是一样的）。

操作系统是非常关爱运行的每一个进程的，当检测到某一个进程变成了孤儿进程，这时候系统中就会有一个固定的进程领养这个孤儿进程（有干爹了）。

如果使用 Linux 没有桌面终端，这个领养孤儿进程的进程就是 `init `进程（PID=1），如果有桌面终端，这个领养孤儿进程就是桌面进程。

那么问题来了，系统为什么要领养这个孤儿进程呢？**在子进程退出的时候, 进程中的用户区可以自己释放, 但是进程内核区的`pcb`资源自己无法释放，必须要由父进程来释放子进程的`pcb`资源**，孤儿进程被领养之后，这件事儿干爹就可以代劳了，这样可以避免系统资源的浪费。

```cpp
int main() {
  // 创建子进程
  pid_t pid = fork();

  // 父进程
  if (pid > 0) {
    printf("Father process, pid=%d\n", getpid());
  } else if (pid == 0) {
    sleep(1);  // 强迫子进程睡眠1s, 这个期间, 父进程退出, 当前进程变成了孤儿进程
    // 子进程
    printf("Son process, pid=%d, My father process: %d\n", getpid(), getppid());
  }
  return 0;
}
```



### 僵尸进程

在一个启动的进程中创建子进程，这时候就有了父子两个进程，父进程正常运行，子进程先结束，**子进程无法释放自己的 PCB 资源，需要父进程来做这个件事儿，但是如果父进程也不管，这时候子进程就变成了僵尸进程。**

僵尸进程不能将它看成是一个正常的进程，这个进程已经死亡了，用户区资源已经被释放了，只是还占用着一些内核资源（PCB）。 僵尸进程就相当于是一副已经腐烂只剩下骨头的尸体。

**僵尸进程的出现是由于这个已死亡的进程的父进程不作为造成的。**

```cpp
int main() {
  pid_t pid;
  // 创建子进程
  for (int i = 0; i < 5; ++i) {
    pid = fork();
    if (pid == 0) {
      break;
    }
  }

  // 父进程
  if (pid > 0) {
    // 需要保证父进程一直在运行
    // 一直运行不退出, 并且也做回收, 就会出现僵尸进程
    while (1) {
      printf("我是父进程, pid=%d\n", getpid());
      sleep(1);
    }
  } else if (pid == 0) {
    // 子进程, 执行这句代码之后, 子进程退出了
    printf("我是子进程, pid=%d, 父进程ID: %d\n", getpid(), getppid());
  }
  return 0;
}
```

```bash
# ps aux 查看进程信息
# Z+ --> 这个进程是僵尸进程, defunct, 表示进程已经死亡
root        3628  0.0  0.0  13776  1832 pts/0    S+   13:38   0:00 ./main
root        3629  0.0  0.0      0     0 pts/0    Z+   13:38   0:00 [main] <defunct>
root        3630  0.0  0.0      0     0 pts/0    Z+   13:38   0:00 [main] <defunct>
root        3631  0.0  0.0      0     0 pts/0    Z+   13:38   0:00 [main] <defunct>
root        3632  0.0  0.0      0     0 pts/0    Z+   13:38   0:00 [main] <defunct>
root        3633  0.0  0.0      0     0 pts/0    Z+   13:38   0:00 [main] <defunct>
```

> 消灭僵尸进程的方法是，杀死这个僵尸进程的父进程，这样僵尸进程的资源就被系统回收了。通过 kill -9 僵尸进程PID 的方式是不能消灭僵尸进程的，这个命令只对活着的进程有效，僵尸进程已经死了，鞭尸是不能解决问题的。
>



## 进程回收

为了避免僵尸进程的产生，一般我们会在父进程中进行子进程的资源回收，回收方式有两种，一种是阻塞方式 `wait()`，一种是非阻塞方式` waitpid()`。

### wait()

这是个阻塞函数，如果没有子进程退出，函数会一直阻塞等待，当检测到子进程退出了，该函数阻塞解除回收子进程资源。这个函数被调用一次，只能回收一个子进程的资源，如果有多个子进程需要资源回收，函数需要被调用多次。

```cpp
// man 2 wait
#include <sys/wait.h>
pid_t wait(int *status);
```

参数：传出参数，通过传递出的信息判断回收的进程是怎么退出的，如果不需要该信息可以指定为 NULL。取出整形变量中的数据需要使用一些**宏函数**，具体操作方式如下：

- `WIFEXITED(status)` ：返回 1, 进程是正常退出的
- `WEXITSTATUS(status)`：得到进程退出时候的状态码，相当于 return 后边的数值，或者 exit () 函数的参数
- `WIFSIGNALED(status)`： 返回 1, 进程是被信号杀死了
- `WTERMSIG(status)`：获得进程是被哪个信号杀死的，会得到信号的编号

返回值:

- 成功：返回被回收的子进程的进程 ID
- 失败：-1。没有子进程资源可以回收了，函数的阻塞会自动解除，返回 - 1。回收子进程资源的时候出现了异常



```cpp
#include <unistd.h>

#include <cstdio>
// wait 函数回收子进程资源
#include <sys/wait.h>

int main() {
  pid_t pid;
  // 创建子进程
  for (int i = 0; i < 5; ++i) {
    pid = fork();
    if (pid == 0) {
      break;
    }
  }

  // 父进程
  if (pid > 0) {
    // 需要保证父进程一直在运行
    while (1) {
      // 回收子进程的资源
      // 子进程由多个, 需要循环回收子进程资源
      pid_t ret = wait(NULL);
      if (ret > 0) {
        printf("成功回收了子进程资源, 子进程PID: %d\n", ret);
      } else {
        printf("回收失败, 或者是已经没有子进程了...\n");
        break;
      }
      printf("我是父进程, pid=%d\n", getpid());
    }
  } else if (pid == 0) {
    // 子进程, 执行这句代码之后, 子进程退出了
    printf("我是子进程, pid=%d, 父进程ID: %d\n", getpid(), getppid());
  }
  return 0;
}
```



### waitpid()

`waitpid ()` 函数可以看做是 wait () 函数的升级版，通过该函数可以控制回收子进程资源的方式是阻塞还是非阻塞，另外还可以通过该函数进行精准打击，可以精确指定回收某个或者某一类或者是全部子进程资源。

```bash
// man 2 waitpid
#include <sys/wait.h>
// 这个函数可以设置阻塞, 也可以设置为非阻塞
// 这个函数可以指定回收哪些子进程的资源
pid_t waitpid(pid_t pid, int *status, int options);
```

pid:

- -1：回收所有的子进程资源，和 wait () 是一样的，无差别回收，并不是一次性就可以回收多个，也是需要循环回收的
- 大于0：指定回收某一个进程的资源 ，pid 是要回收的子进程的进程 ID
- 0：回收当前进程组的所有子进程 ID
- 小于 -1：pid 的绝对值代表进程组 ID，表示要回收这个进程组的所有子进程资源

status: NULL, 和 wait 的参数是一样的

options: 控制函数是阻塞还是非阻塞

- 0: 函数是行为是阻塞的 ==> 和 wait 一样
- `WNOHANG`: 函数是行为是非阻塞的

返回值:

- 如果函数是非阻塞的，并且子进程还在运行，返回 0
- 成功：得到子进程的进程 ID
- 失败: -1。没有子进程资源可以回收了，函数如果是阻塞的，阻塞会解除，直接返回 - 1。回收子进程资源的时候出现了异常

```cpp
#include <unistd.h>

#include <cstdio>
// 非阻塞处理
#include <sys/wait.h>

int main() {
  pid_t pid;
  // 创建子进程
  for (int i = 0; i < 5; ++i) {
    pid = fork();
    if (pid == 0) {
      break;
    }
  }

  // 父进程
  if (pid > 0) {
    // 需要保证父进程一直在运行
    while (1) {
      // 回收子进程的资源
      // 子进程由多个, 需要循环回收子进程资源
      // 子进程退出了就回收,
      // 没退出就不回收, 返回0
      int status;
      pid_t ret = waitpid(-1, &status, WNOHANG);  // 非阻塞
      if (ret > 0) {
        printf("成功回收了子进程, PID: %d\n", ret);
        sleep(1);

        // 判断进程是不是正常退出
        if (WIFEXITED(status)) {
          printf("子进程退出时候的状态码: %d\n", WEXITSTATUS(status));
        }
        if (WIFSIGNALED(status)) {
          printf("子进程是被这个信号杀死的: %d\n", WTERMSIG(status));
        }
      } else if (ret == 0) {
        printf("子进程还没有退出, 不做任何处理...\n");
      } else {
        printf("回收失败, 或者是已经没有子进程了...\n");
        break;
      }
    }
    printf("我是父进程, pid=%d\n", getpid());
  } else if (pid == 0) {
    // 子进程, 执行这句代码之后, 子进程退出了
    printf("我是子进程, pid=%d, 父进程ID: %d\n", getpid(), getppid());
  }
  return 0;
}
```











































