# IO多路复用

IO 多路转接也称为 IO 多路复用，它是一种网络通信的手段（机制），通过这种方式可以同时监测多个文件描述符并且这个过程是阻塞的，一旦检测到有文件描述符就绪（ 可以读数据或者可以写数据）程序的阻塞就会被解除，之后就可以基于这些（一个或多个）就绪的文件描述符进行通信了。**通过这种方式在单线程 / 进程的场景下也可以在服务器端实现并发。**常见的 IO 多路转接方式有：select、poll、epoll。

下面先对多线程 / 多进程并发和 IO 多路转接的并发处理流程进行对比（服务器端）。

## 多线程 / 多进程并发

主线程 / 父进程：调用 accept() 监测客户端连接请求

- 如果没有新的客户端的连接请求，当前线程 / 进程会阻塞
- 如果有新的客户端连接请求解除阻塞，建立连接

子线程 / 子进程：和建立连接的客户端通信

- 调用 read() / recv() 接收客户端发送的通信数据，如果没有通信数据，当前线程 / 进程会阻塞，数据到达之后阻塞自动解除
- 调用 write() / send() 给客户端发送数据，如果写缓冲区已满，当前线程 / 进程会阻塞，否则将待发送数据写入写缓冲区中

## IO 多路转接并发

使用 IO 多路转接函数委托内核检测服务器端所有的文件描述符（通信和监听两类），这个检测过程会导致进程 / 线程的阻塞，如果检测到已就绪的文件描述符阻塞解除，并将这些已就绪的文件描述符传出

根据类型对传出的所有已就绪文件描述符进行判断，并做出不同的处理

监听的文件描述符：和客户端建立连接

此时调用 accept() 是不会导致程序阻塞的，因为监听的文件描述符是已就绪的（有新请求）

通信的文件描述符：调用通信函数和已建立连接的客户端通信

调用 read() / recv() 不会阻塞程序，因为通信的文件描述符是就绪的，读缓冲区内已有数据

调用 write() / send() 不会阻塞程序，因为通信的文件描述符是就绪的，写缓冲区不满，可以往里面写数据

对这些文件描述符继续进行下一轮的检测（循环往复。。。）

与多进程和多线程技术相比，I/O 多路复用技术的最大优势是系统开销小，系统不必创建进程 / 线程，也不必维护这些进程 / 线程，从而大大减小了系统的开销。







## Reference

 [Linux IO模式及 select、poll、epoll详解](https://segmentfault.com/a/1190000003063859)



















