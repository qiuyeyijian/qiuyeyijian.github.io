2.Shell脚本中的set指令，比如set -x 和 set -e

# set参数介绍

set指令能设置所使用shell的执行方式，可依照不同的需求来做设置
　-a 　标示已修改的变量，以供输出至环境变量。
　-b 　使被中止的后台程序立刻回报执行状态。
　-C 　转向所产生的文件无法覆盖已存在的文件。
　-d 　Shell预设会用杂凑表记忆使用过的指令，以加速指令的执行。使用-d参数可取消。
　-e 　若指令传回值不等于0，则立即退出shell。　　
　-f　 　取消使用通配符。
　-h 　自动记录函数的所在位置。
　-H Shell 　可利用"!"加<指令编号>的方式来执行history中记录的指令。
　-k 　指令所给的参数都会被视为此指令的环境变量。
　-l 　记录for循环的变量名称。
　-m 　使用监视模式。
　-n 　只读取指令，而不实际执行。
　-p 　启动优先顺序模式。
　-P 　启动-P参数后，执行指令时，会以实际的文件或目录来取代符号连接。
　-t 　执行完随后的指令，即退出shell。
　-u 　当执行时使用到未定义过的变量，则显示错误信息。
　-v 　显示shell所读取的输入值。
　-x 　执行指令后，会先显示该指令及所下的参数。
　+<参数> 　取消某个set曾启动的参数。

# set -x介绍

用于脚本调试，在liunx脚本中可用set -x就可有详细的日志输出.免的老是要echo了

示例

```
#!/bin/bash``set` `-x``a=${1}``b=$
```

运行结果

```
bash a.sh 1 2``+ a=1``+ b=1
```

　　

# set -e介绍

```bash
-----------------------------------------------------------
#!/bin/bash
set -e
command 1
command 2
...
exit 0
----------------------------------------------------------
```

你写的每个脚本都应该在文件开头加上set -e,这句语句告诉bash如果任何语句的执行结果不是true则应该退出。这样的好处是防止错误像滚雪球般变大导致一个致命的错误，而这些错误本应该在之前就被处理掉。如果要增加可读性，可以使用set -o errexit，它的作用与set -e相同。

使用-e帮助你检查错误。如果你忘记检查（执行语句的结果），bash会帮你执行。不幸的是，你将无法检查$?，因为如果执行的语句不是返回0，bash将无法执行到检查的代码。你可以使用其他的结构：

```bash
command  
if [ "$?"-ne 0]; then   
    echo "command failed";   
    exit 1;   
fi   
could be replaced with
```

能够被代替为
`command || { echo "command failed"; exit 1; }`

或者

```bash
if ! command; then  
     echo "command failed";   
    exit 1;   
fi  
```

如果你有一个命令返回非0或者你对语句执行的结果不关心，那你可以使用command || true，或者你有一段很长的代码，你可以关闭错误检查（不使用set -e），但是我还是建议你保守地使用这个语句。