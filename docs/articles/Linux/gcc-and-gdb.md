# GCC 和 GDB

GCC 是 Linux 下的编译工具集，是 GNU Compiler Collection 的缩写，包含 gcc、g++ 等编译器。这个工具集不仅包含编译器，还包含其他工具集，例如 ar、nm 等。

GCC 工具集不仅能编译 C/C++ 语言，其他例如 Objective-C、Pascal、Fortran、Java、Ada 等语言均能进行编译。GCC 在可以根据不同的硬件平台进行编译，即能进行交叉编译，在 A 平台上编译 B 平台的程序，支持常见的 X86、ARM、PowerPC、mips 等，以及 Linux、Windows 等软件平台。

https://www.cnblogs.com/welhzh/p/6730839.html

## GCC 工作流程

预处理：在这个阶段主要做了三件事: **展开头文件 、宏替换 、去掉注释行**。这个阶段需要 GCC 调用预处理器来完成，最终得到的还是源文件，文本格式

编译：这个阶段需要 GCC 调用编译器对文件进行编译，最终得到一个汇编文件

汇编：这个阶段需要 GCC 调用汇编器对文件进行汇编，最终得到一个二进制文件

链接：这个阶段需要 GCC 调用链接器对程序需要调用的库进行链接，最终得到一个可执行的二进制文件

```bash
# 预处理。主要工作是：头文件的引入、宏的展开、指令的处理
gcc -E test.c -o test.i
# 编译。主要工作是：得到汇编文件
gcc -S test.i -o test.s
# 汇编。主要工作是：对得到的汇编文件进行汇编，得到二进制文件（还不可以执行）
gcc -c test.s -o test.o
# 链接。主要工作是：将得到的二进制文件和标准库进制链接，得到可执行的二进制文件
gcc test.o -o test
```

真正编译的时候可以通过参数跳过步骤，直接得到可执行文件：

```bash
# 参数 -c 是进行文件的汇编, 汇编之前的两步会自动执行
gcc test.c -c -o test.o

# 该命令是直接进行链接生成可执行程序, 链接之前的三步会自动执行
gcc test.c -o test
```

## GCC 常用参数

这些参数在 gcc 命令中没有位置要求，只需要编译程序的时候将需要的参数指定出来即可。

| gcc 编译选项               | 选项的意义                                                                                       |
| -------------------------- | ------------------------------------------------------------------------------------------------ |
| `=-I `directory (大写的 I) | 指定 include 包含文件的搜索目录                                                                  |
| `=-g`                      | 在编译的时候，生成调试信息，该程序可以被调试器调试                                               |
| `=-On`                     | n 的取值范围：0~3。编译器的优化选项的 4 个级别，-O0 表示没有优化，-O1 为缺省值，-O3 优化级别最高 |
| `=-l`                      | 在程序编译的时候，指定使用的库                                                                   |
| `=-L`                      | 指定编译的时候，搜索的库的路径。                                                                 |
| `=-fPIC/fPIC`              | 生成与位置无关的代码                                                                             |
| `=-shared`                 | 生成共享目标文件。通常用在建立共享库时                                                           |
| `=-std`                    | 指定 C 方言，如:-std=c99，gcc 默认的方言是 GNU C                                                 |
| =-D                        | 在程序编译的时候，指定一个宏                                                                     |
| =-w                        | 不生成任何警告信息，不建议使用，有些时候警告就是错误                                             |
| =-Wall                     | 生成所有警告信息                                                                                 |

### 指定一个宏（-D）

在程序中我们可以使用宏定义一个常量，也可以通过宏控制某段代码是否能够被执行。

在下面这段程序中是否定义了一个叫做 DEBUG 的宏，如果没有定义则被宏包围的语句就不会被执行了

```cpp
#include <stdio.h>

int main() {
  int a = 10;

#ifdef DEBUG
  printf("Debug log...\n");
#endif

  printf("Hello, world!\n");

  return 0;
}
```

如果不想在程序中定义这个宏， 但是又想让它存在，通过 gcc 的参数 -D 就可以实现了，编译器会认为参数后边指定的宏在程序中是存在的。

```bash
# 在编译命令中定义这个 DEBUG 宏,
gcc test.c -o app -D DEBUG
```

> -D 参数的应用场景:
>
> 在发布程序的时候，一般都会要求将程序中所有的 log 输出去掉，如果不去掉会影响程序的执行效率，很显然删除这些打印 log 的源代码是一件很麻烦的事情，解决方案是这样的：
>
> 将所有的打印 log 的代码都写到一个宏判定中，可以模仿上边的例子。在编译程序的时候指定 -D 就会有 log 输出。在编译程序的时候不指定 -D, log 就不会输出

## GCC 与 G++

不管是 gcc 还是 g++ 都可以编译 C 程序，编译程序的规则和参数都相同

g++ 可以直接编译 C++ 程序， gcc 编译 C++ 程序需要添加额外参数 `-lstdc++`

不管是 gcc 还是 g++ 都可以定义 `__cplusplus `宏

# GDB

`gdb `是由 GNU 软件系统社区提供的调试器，同 gcc 配套组成了一套完整的开发环境，可移植性很好，支持非常多的体系结构并被移植到各种系统中（包括各种类 Unix 系统与 Windows 系统里的 MinGW 和 Cygwin ）。此外，除了 C 语言之外，gcc/gdb 还支持包括 C++、Objective-C、Ada 和 Pascal 等各种语言后端的编译和调试。 gcc/gdb 是 Linux 和许多类 Unix 系统中的标准开发环境，Linux 内核也是专门针对 gcc 进行编码的。

gdb 的吉祥物是专门捕杀 bug 的射手鱼，官方有这样一段描述：

> For a fish, the archer fish is known to shoot down **bugs** from low hanging plants by spitting water at them.
>
> 作为一种鱼，射手鱼以喷水射下低垂的植物上的虫子而闻名。

GDB 是一套字符界面的程序集，可以使用命令 gdb 加载要调试的程序。

## 调试准备

项目程序如果是为了进行调试而编译时， 必须要打开调试选项 (-g)。

另外还有一些可选项，比如：`-O0`在尽量不影响程序行为的情况下关掉编译器的优化选项 ，`-Wall` 选项打开所有 warning，也可以发现许多问题，避免一些不必要的 bug。

`-g `选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，**所以在调试时必须保证 gdb 能找到源文件。**

> 假设有一个文件 `args.c`, 要对其进行 gdb 调试，编译的时候必须要添加参数 -g，**加入了源代码信息的可执行文件比不加之前要大一些。**

```bash
gcc -g test.c -o test
```

## 启动和退出 GDB

**进行 GDB 调试之前，待调试的可执行文件不能被执行。**

```bash
gdb test		# 开始调试程序
```

### 命令行传参

**有些程序在启动的时候需要传递命令行参数**，如果要调试这类程序，这些命令行参数必须要在应用程序启动之前通过调试程序的 gdb 进程传递进去。

```bash
(gdb) set args 参数1 参数2 ...
(gdb) show args			# 查看设置的命令行参数
```

### GDB 中启动程序

在 gdb 中启动要调试的应用程序有两种方式，一种是使用` run` 命令，另一种是使用` start` 命令启动。**在整个 gdb 调试过程中，启动应用程序的命令只能使用一次。**

`run`：可以缩写为 `r`, 如果程序中设置了断点会停在第一个断点的位置，如果没有设置断点，程序就执行完了

`start`：启动程序，最终会阻塞在 main 函数的第一行，等待输入后续其它 gdb 指令

`continue`：可以简写为` c`，让程序 start 之后继续运行，或者在断点处继续运行，

### 退出 GDB

退出 gdb 调试，就是终止 gdb 进程，需要使用 `quit` 命令，可以缩写为 `q`

## 查看代码

查看代码的命令叫做`list`可以缩写为` l`, 通过这个命令我们可以查看项目中任意一个文件中的内容，并且还可以通过文件行号，函数名等方式查看。

### 当前文件

一个项目中一般是有很多源文件的，默认情况下通过 list 查看到代码信息位于程序入口函数 main 对应的的那个文件中。因此如果不进行文件切换 main 函数所在的文件就是当前文件，如果进行了文件切换，切换到哪个文件哪个文件就是当前文件。查看文件内容的方式如下：

```bash
# 使用 list 和使用 l 都可以
# 从第一行开始显示
(gdb) list

# 列值这行号对应的上下文代码, 默认情况下只显示10行内容
(gdb) list 行号

# 显示这个函数的上下文内容, 默认显示10行
(gdb) list 函数名
```

通过 list 去查看文件代码，默认只显示 10 行，如果还想继续查看后边的内容，可以继续执行 list 命令，也可以直接回车（再次执行上一次执行的那个 gdb 命令）。

### 切换文件

在查看文件内容的时候，很多情况下需要进行文件切换，我们只需要在 list 命令后边将要查看的文件名指定出来就可以了，切换命令执行完毕之后，这个文件就变成了当前文件。文件切换方式如下：

```bash
# 切换到指定的文件，并列出这行号对应的上下文代码, 默认情况下只显示10行内容
(gdb) l 文件名:行号

# 切换到指定的文件，并显示这个函数的上下文内容, 默认显示10行
(gdb) l 文件名:函数名
```

### 设置显示的行数

默认通过 list 只能一次查看 10 行代码，如果想显示更多，可以通过 set listsize 设置，同样如果想查看当前显示的行数可以通过 show listsize 查看，这里的 listsize 可以简写为 list。具体语法格式如下:

```bash
# 以下两个命令中的 listsize 都可以写成 list
(gdb) set listsize 行数

# 查看当前list一次显示的行数
(gdb) show listsize
```

## 断点操作

想要通过 gdb 调试某一行或者得到某个变量在运行状态下的实际值，就需要在在这一行设置断点，程序指定到断点的位置就会阻塞，我们就可以通过 gdb 的调试命令得到我们想要的信息了。

设置断点的命令叫做 `break `可以缩写为` b`。

### 设置断点

断点的设置有两种方式一种是**常规断点**，程序只要运行到这个位置就会被阻塞，还有一种叫**条件断点**，只有指定的条件被满足了程序才会在断点处阻塞。

调试程序的断点可以设置到某个具体的行，也可以设置到某个函数上，具体的设置方式如下：

```bash
# 在当前文件的某一行上设置断点
# break == b
(gdb) b 行号
(gdb) b 函数名		# 停止在函数的第一行

# 在非当前文件的某一行上设置断点
(gdb) b 文件名:行号
(gdb) b 文件名:函数名		# 停止在函数的第一行

# 必须要满足某个条件, 程序才会停在这个断点的位置上
# 通常情况下, 在循环中条件断点用的比较多
(gdb) b 行数 if 变量名==某个值
```

### 查看断点

断点设置完毕之后，可以通过 `info break `命令查看设置的断点信息，可缩写为：`i b`

```bash
# info == i
# 查看设置的断点信息
(gdb) i b   #info break

# 举例
(gdb) i b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000400cb5 in main() at test.cpp:12
2       breakpoint     keep y   0x00000000004009a5 in insertionSort(int*, int)
                                                   at insert.cpp:8
3       breakpoint     keep y   0x0000000000400cdd in main() at test.cpp:16
4       breakpoint     keep y   0x00000000004009e5 in insertionSort(int*, int)
```

在显示的断点信息中有一些属性需要在其他操作中被使用，下面介绍一下:

- Num: 断点的编号，删除断点或者设置断点状态的时候都需要使用
- Enb: 当前断点的状态，y 表示断点可用，n 表示断点不可用
- What: 描述断点被设置在了哪个文件的哪一行或者哪个函数上

### 删除断点

如果确定设置的某个断点不再被使用了，可用将其删除，删除命令是 delete 断点编号 , 这个 delete 可以简写为 del 也可以再简写为 d。

删除断点的方式有两种: 删除(一个或者多个)指定断点或者删除一个连续的断点区间，具体操作如下：

```bash
# delete == del == d
# 需要 info b 查看断点的信息, 第一列就是编号
(gdb) d 断点的编号1 [断点编号2 ...]
# 举例:
(gdb) d 1          # 删除第1个断点
(gdb) d 2 4 6      # 删除第2,4,6个断点

# 删除一个范围, 断点编号 num1 - numN 是一个连续区间
(gdb) d num1-numN
# 举例, 删除第1到第5个断点
(gdb) d 1-5
```

### 设置断点状态

如果某个断点只是临时不需要了，我们可以将其设置为不可用状态，设置命令为 disable 断点编号，当需要的时候再将其设置回可用状态，设置命令为 enable 断点编号。

```bash
# 让断点失效之后, gdb调试过程中程序是不会停在这个位置的
# disable == dis
# 设置某一个或者某几个断点无效
(gdb) dis 断点1的编号 [断点2的编号 ...]

# 设置某个区间断点无效
(gdb) dis 断点1编号-断点n编号
```

## 调试命令

### 继续运行

如果调试的程序被断点阻塞了又想让程序继续执行，这时候就可以使用 continue 命令。程序会继续运行，直到遇到下一个有效的断点。`continue `可以缩写为 `c`。

### 手动打印信息

当程序被某个断点阻塞之后，可以通过一些命令打印变量的名字或者变量的类型，并且还可以跟踪打印某个变量的值。

在 gdb 调试的时候如果需要打印变量的值， 使用的命令是 `print`, 可缩写为 `p`。如果打印的变量是整数还可以指定输出的整数的格式，格式化输出的整数对应的字符表如下：

| 格式化字符 (/fmt) |                 说明                 |
| :---------------: | :----------------------------------: |
|        /x         |     以十六进制的形式打印出整数。     |
|        /d         |  以有符号、十进制的形式打印出整数。  |
|        /u         |  以无符号、十进制的形式打印出整数。  |
|        /o         |      以八进制的形式打印出整数。      |
|        /t         |      以二进制的形式打印出整数。      |
|        /f         | 以浮点数的形式打印变量或表达式的值。 |
|        /c         |   以字符形式打印变量或表达式的值。   |

```bash
# print == p
(gdb) p 变量名

# 如果变量是一个整形, 默认对应的值是以10进制格式输出, 其他格式请参考上表
(gdb) p/fmt 变量名

# 举例
(gdb) p/x i     # 16进制
$6 = 0x3
(gdb) p/o i     # 8进制
$7 = 03
```

如果在调试过程中需要查看某个变量的类型，可以使用命令 `ptype`, 语法格式如下:

```bash
(gdb) ptype 变量名
```

### 自动打印信息

和 print 命令一样，display 命令也用于调试阶段查看某个变量或表达式的值。

它们的区别是，使用 display 命令查看变量或表达式的值，**每当程序暂停执行（例如单步执行）时，GDB 调试器都会自动帮我们打印出来，而 print 命令则不会。**

因此，当我们想频繁查看某个变量或表达式的值从而观察它的变化情况时，使用 display 命令可以一劳永逸。display 命令没有缩写形式，常用的语法格式如下 2 种：

```bash
# 在变量的有效取值范围内, 自动打印变量的值(设置一次, 以后就会自动显示)
(gdb) display 变量名

# 以指定的整形格式打印变量的值, 关于 fmt 的取值, 请参考 print 命令
(gdb) display/fmt 变量名
```

对于使用 display 命令查看的目标变量或表达式，都会被记录在一张列表（称为自动显示列表）中。通过执行 `info dispaly `命令，可以打印出这张表：

```bash
# info == i
(gdb) info display
Auto-display expressions now in effect:
Num Enb Expression
1:   y  i
2:   y  array[i]
3:   y  /x array[i]
```

在展示出的信息中，每个列的含义如下:

- `Num` : 变量或表达式的编号，GDB 调试器为每个变量或表达式都分配有唯一的编号
- `Enb` : 表示当前变量（表达式）是处于激活状态还是禁用状态，如果处于激活状态（用 y 表示），则每次程序停止执行，该变量的值都会被打印出来；反之，如果处于禁用状态（用 n 表示），则该变量（表达式）的值不会被打印。
- `Expression` ：被自动打印值的变量或表达式的名字。

对于不需要再打印值的变量或表达式，可以将其删除或者禁用。

```cpp
# 命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个
(gdb) undisplay num [num1 ...]
# num1 - numN 表示一个范围
(gdb) undisplay num1-numN

(gdb) delete display num [num1 ...]
(gdb) delete display num1-numN
```

如果不想删除自动显示的变量，也可以禁用自动显示列表中处于激活状态下的变量或表达式。

```bash
# 命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个
(gdb) disable display num [num1 ...]
# num1 - numN 表示一个范围
(gdb) disable display num1-numN
```

当需要启用自动显示列表中被禁用的变量或表达式时，可以使用下边的命令。

```bash
# 命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个
(gdb) enable  display num [num1 ...]
# num1 - numN 表示一个范围
(gdb) enable display num1-numN
```

## 单步调试

当程序阻塞到某个断点上之后，可以通过以下命令对程序进行单步调试:

### step

step 命令可以缩写为 s, 命令被执行一次代码被向下执行一行，如果这一行是一个函数调用，那么程序会进入到函数体内部。

```bash
# 从当前代码行位置, 一次调试当前行下的每一行代码
# step == s
# 如果这一行是函数调用, 执行这个命令, 就可以进入到函数体的内部
(gdb) step
```

### finish

如果通过 s 单步调试进入到函数内部，想要跳出这个函数体， 可以执行 finish 命令。如果想要跳出函数体必须要保证函数体内不能有有效断点，否则无法跳出。

```bash
# 如果通过 s 单步调试进入到函数内部, 想要跳出这个函数体
(gdb) finish
```

### next

next 命令和 step 命令功能是相似的，只是在使用 next 调试程序的时候不会进入到函数体内部，next 可以缩写为 n。

```bash
# next == n
# 如果这一行是函数调用, 执行这个命令, 不会进入到函数体的内部
(gdb) next
```

### until

通过 until 命令可以直接跳出某个循环体，这样就能提高调试效率了。如果想直接从循环体中跳出，必须要满足以下的条件，否则命令不会生效：

- 要跳出的循环体内部不能有有效的断点
- 必须要在循环体的开始 / 结束行执行该命令

```bash
(gdb) until
```

## 设置变量的值

在调试程序的时候，我们需要在某个变量等于某个特殊值的时候查看程序的运行状态，但是通过程序运行让变量等于这个值又非常困难，这种情况下就可以在 gdb 中直接对这个变量进行值的设置，或者是在单步调试的时候通过设置循环因子的值直接跳出某个循环，值设置的命令格式为: set var 变量名=值

```bash
# 可以在循环中使用, 直接设置循环因子的值
# 假设某个变量的值在程序中==90的概率是5%, 这时候可以直接通过命令将这个变量值设置为90
(gdb) set var 变量名=值
```

## 常用命令汇总

```bash
gdb test  # 启动GDB
(gdb) list 行号  # 列出源码，缩写是 l
(gdb)       # 直接回车表示重复上一次命令
(gdb) break 16  # 设置断点，在源程序第16行处, 缩写是 b
(gdb) break func  # 设置断点，在函数func()入口处
(gdb) info break    # 查看断点信息, 缩写是 i
(gdb) run      # 运行程序， 缩写是 r
(gdb) next    # 单条语句执行, 缩写是 n
(gdb) continue    # 继续运行程序, 缩写是 c
(gdb) print i    # 打印变量 i 的值, 缩写是 p
(gdb) bt    # 查看函数堆栈
(gdb) finish  # 退出函数
(gdb) quit    # 退出gdb
(gdb) step  # 单步调试，可以进入函数内部
```
