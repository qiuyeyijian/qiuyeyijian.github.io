# 管道符、重定向与环境变量

简而言之，输入重定向是指把文件导入到命令中，而输出重定向则是指把原本要输出到屏幕的数据信息写入到指定文件中。在日常的学习和工作中，相较于输入重定向，我们使用输出重定向的频率更高，所以又将输出重定向分为了标准输出重定向和错误输出重定向两种不同的技术，以及覆盖写入与追加写入两种模式。

> **标准输入重定向（STDIN，文件描述符为0）**：默认从键盘输入，也可从其他文件或命令中输入。
>
> **标准输出重定向（STDOUT，文件描述符为1）**：默认输出到屏幕。
>
> **错误输出重定向（STDERR，文件描述符为2）**：默认输出到屏幕。



| 符号                 | 作用                                         |
| -------------------- | -------------------------------------------- |
| 命令 < 文件          | 将文件作为命令的标准输入                     |
| 命令 << 分界符       | 从标准输入中读入，直到遇见分界符才停止       |
| 命令 < 文件1 > 文件2 | 将文件1作为命令的标准输入并将标准输出到文件2 |

| 符号          | 作用                                                         |
| ------------- | ------------------------------------------------------------ |
| 命令 > 文件   | 将标准输出重定向到一个文件中（清空原有文件的数据）           |
| 命令 >> 文件  | 将标准输出重定向到一个文件中（追加到原有内容的后面）         |
| 命令 &>> 文件 | 将标准输出与错误输出共同写入到文件中（追加到原有内容的后面） |
| 命令 2> 文件  | 将错误输出重定向到一个文件中（清空原有文件的数据）           |
| 命令 2>> 文件 | 将错误输出重定向到一个文件中（追加到原有内容的后面）         |

注意：上面的`2`表示文件描述符。建议使用`&>`和`&>>`，这样无论命令正确与否，结果都会输出到文件中

```bash
wc -l < 1.txt		# 统计行数，只显示行数，没有文件名称
wc -l 1.txt			# 统计行数，显示行数加文件名称
```

这是因为此前使用的“wc -l /etc/passwd”是一种非常标准的“命令+参数+对象”的执行格式，而这次的“wc -l < readme.txt”则是将readme.txt文件中的内容通过操作符导入到命令中，没有被当作命令对象进行执行，因此wc命令只能读到信息流数据，而没有文件名称的信息。



## 管道命令符

管道命令符的作用也可以用一句话概括为“**把前一个命令原本要输出到屏幕的信息当作后一个命令的标准输入**”。

```bash
grep /sbin/nologin /etc/passwd | wc -l

ls -l /etc | more		# 用翻页形式查看ls结果

ps aux | grep bash | tee 1.txt
```

在修改用户密码时，通常都需要输入两次密码以进行确认，这在编写自动化脚本时将成为一个非常致命的缺陷。通过把管道符和passwd命令的--stdin参数相结合，可以用一条命令来完成密码重置操作：

```bash
echo "123456" | passwd --stdin root
```





## 命令行的通配符

顾名思义，通配符就是通用的匹配信息的符号，比如星号（*）代表匹配零个或多个字符，问号（?）代表匹配单个字符，中括号内加上数字[0-9]代表匹配0～9之间的单个数字的字符，而中括号内加上字母[abc]则是代表匹配a、b、c三个字符中的任意一个字符。

| 通配符      | 含义           |
| ----------- | -------------- |
| *           | 任意字符       |
| ?           | 单个任意字符   |
| [a-z]       | 单个小写字母   |
| [A-Z]       | 单个大写字母   |
| [a-Z]       | 单个字母       |
| [0-9]       | 单个数字       |
| [[:alpha:]] | 任意字母       |
| [[:upper:]] | 任意大写字母   |
| [[:lower:]] | 任意小写字母   |
| [[:digit:]] | 所有数字       |
| [[:alnum:]] | 任意字母加数字 |
| [[:punct:]] | 标点符号       |

```bash
ls -l /dev/sda*
ls -l /dev/sda[0-9]
ls -l /dev/sda[135]		# 匹配135数字中的任意一个

touch {a,b,c}.txt		# 批量创建3个文件

```





## 常用的转义字符

> **反斜杠（\）**：使反斜杠后面的一个变量变为单纯的字符。
>
> **单引号（' '）**：转义其中所有的变量为单纯的字符串。
>
> **双引号（" "）**：保留其中的变量属性，不进行转义处理。
>
> **反引号（\` `）**：把其中的命令执行后返回结果。

```bash
echo "Shell is $SHELL"
echo `uname -a`

```



这里给大家总结一个简单小技巧，虽然可能不够严谨，但绝对简单：如果参数中出现了空格，就加双引号；如果参数中没有空格，那就不用加双引号。



## 重要的环境变量

变量是计算机系统用于保存可变值的数据类型。在Linux系统中，变量名称一般都是大写的，命令则都是小写的，这是一种约定俗成的规范。Linux系统中的环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录、邮件存放位置等。可以直接通过变量名称来提取到对应的变量值。

在用户执行了一条命令之后，Linux系统中到底发生了什么事情呢？简单来说，命令在Linux中的执行分为4个步骤。

**第1步**：判断用户是否以绝对路径或相对路径的方式输入命令（如/bin/ls），如果是绝对路径则直接执行，否则进入第2步继续判断。

**第2步**：Linux系统检查用户输入的命令是否为“别名命令”，即用一个自定义的命令名称来替换原本的命令名称。可以用alias命令来创建一个属于自己的命令别名，语法格式为“alias别名=命令”。若要取消一个命令别名，则是用unalias命令，语法格式为“unalias别名”。

**第3步**：Bash解释器判断用户输入的是内部命令还是外部命令。内部命令是解释器内部的指令，会被直接执行；而用户在绝大部分时间输入的是外部命令，这些命令交由步骤4继续处理。可以使用“type命令名称”来判断用户输入的命令是内部命令还是外部命令：

**第4步**：系统在多个路径中查找用户输入的命令文件，而定义这些路径的变量叫作PATH，可以简单地把它理解成是“解释器的小助手”，作用是告诉Bash解释器待执行的命令可能存放的位置，然后Bash解释器就会乖乖地在这些位置中逐个查找。PATH是由多个路径值组成的变量，每个路径值之间用冒号间隔，对这些路径的增加和删除操作将影响到Bash解释器对Linux命令的查找。



其实变量是由固定的变量名与用户或系统设置的变量值两部分组成的，我们完全可以自行创建变量来满足工作需求。

```bash
WORKPLACE = /root/workplace
```

如果工作需要，可以使用export命令将其提升为全局变量，这样其他用户也就可以使用它了：

```bash
export WORKPLACE
```

后续要是不使用这个变量了，则可执行unset命令把它取消掉：

```bash
unset WORKPLACE
```

> 直接在终端设置的变量能够立即生效，但在重启服务器后就会失效，因此我们需要将变量和变量值写入到.bashrc或者.bash_profile文件中，以确保永久能使用它们。



