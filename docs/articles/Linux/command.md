# 核心命令

## 系统工作命令

### wget

wget命令用于在终端命令行中下载网络文件，英文全称为“web get”

| 参数 | 作用                                 |
| ---- | ------------------------------------ |
| -b   | 后台下载模式                         |
| -P   | 下载到指定目录                       |
| -t   | 最大尝试次数                         |
| -c   | 断点续传                             |
| -p   | 下载页面内所有资源，包括图片、视频等 |
| -r   | 递归下载                             |



### ps

ps命令用于查看系统中的进程状态，英文全称为“processes”

| 参数 | 作用                               |
| ---- | ---------------------------------- |
| -a   | 显示所有进程（包括其他用户的进程） |
| -u   | 用户以及其他详细信息               |
| -x   | 显示和终端无关的进程信息           |

在Linux系统中有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。

> **R（运行）**：进程正在运行或在运行队列中等待。
>
> **S（中断）**：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该  状态。
>
> **D（不可中断）**：进程不响应系统异步信号，即便用kill命令也不能将其中断。
>
> **Z（僵死）**：进程已经终止，但进程描述符依然存在, 直到父进程调用wait4()系统函数后将进程释放。
>
> **T（停止）**：进程收到停止信号后停止运行。

**除了上面5种常见的进程状态，还有可能是高优先级（<）、低优先级（N）、被锁进内存（L）、包含子进程（s）以及多线程（l）这5种补充形式。**

| USER         | PID      | %CPU         | %MEM       | VSZ                      | RSS                        | TTY      | STAT     | START        | TIME              | COMMAND        |
| ------------ | -------- | ------------ | ---------- | ------------------------ | -------------------------- | -------- | -------- | ------------ | ----------------- | -------------- |
| 进程的所有者 | 进程ID号 | 运算器占用率 | 内存占用率 | 虚拟内存使用量(单位是KB) | 占用的固定内存量(单位是KB) | 所在终端 | 进程状态 | 被启动的时间 | 实际使用CPU的时间 | 命令名称与参数 |



### pstree

pstree命令用于以树状图的形式展示进程之间的关系，英文全称为“process tree”

### top

top命令用于动态地监视进程活动及系统负载等信息，输入该命令后按回车键执行即可。

前面介绍的命令都是静态地查看系统状态，不能实时滚动最新数据，而top命令能够动态地查看系统状态，因此完全可以将它看作是Linux中“强化版的Windows任务管理器”。

top命令执行结果的前5行为系统整体的统计信息，其所代表的含义如下。

> 第1行：系统时间、运行时间、登录终端数、系统负载（3个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低）。
>
> 第2行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。
>
> 第3行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。其中数据均为CPU数据并以百分比格式显示，例如“99.9 id”意味着有99.9%的CPU处理器资源处于空闲。
>
> 第4行：物理内存总量、内存空闲量、内存使用量、作为内核缓存的内存量。
>
> 第5行：虚拟内存总量、虚拟内存空闲量、虚拟内存使用量、已被提前加载的内存量。

> - PID — 进程id
> - USER — 进程所有者
> - PR — 进程优先级
> - NI — nice值。负值表示高优先级，正值表示低优先级
> - VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES
> - RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
> - SHR — 共享内存大小，单位kb
> - S —进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程
> - %CPU — 上次更新到现在的CPU时间占用百分比
> - %MEM — 进程使用的物理内存百分比
> - TIME+ — 进程使用的CPU时间总计，单位1/100秒
> - COMMAND — 进程名称（命令名/命令行）

```bash
top		 # 进程视角
top -H		# 线程视角
```



### nice

nice命令用于调整进程的优先级，语法格式为“nice优先级数字 服务名称”。

在top命令输出的结果中，PR和NI值代表的是进程的优先级，数字越低（取值范围是-20～19），优先级越高。在日常的生产工作中，可以将一些不重要进程的优先级调低，让紧迫的服务更多地利用CPU和内存资源，以达到合理分配系统资源的目的。例如将bash服务的优先级调整到最高：

```bash
nice -n -20 bash
```

### pidof

pidof命令用于查询某个指定服务进程的PID号码值，语法格式为“pidof [参数] 服务名称”。

每个进程的进程号码值（PID）是唯一的，可以用于区分不同的进程。

```bash
pidof sshd
```



### lsof

```bash
lsof -i:8080					# 查看某一端口占用情况

netstat -tunlp |grep 8080		# 用于查看指定的端口号的进程情况
```



### kill

kill命令用于终止某个指定PID值的服务进程，语法格式为“kill [参数] 进程的PID”。

接下来，使用kill命令把上面用pidof命令查询到的PID所代表的进程终止掉，其命令如下所示。这种操作的效果等同于强制停止sshd服务。

```
kill 2156
```

但有时系统会提示进程无法被终止，此时可以加参数-9，表示最高级别地强制杀死进程：

```
kill -9 2156
```

### killall

killall命令用于终止某个指定名称的服务所对应的全部进程，语法格式为“killall [参数] 服务名称”。

通常来讲，复杂软件的服务程序会有多个进程协同为用户提供服务，如果用kill命令逐个去结束这些进程会比较麻烦，此时可以使用killall命令来批量结束某个服务程序带有的全部进程。

```bash
killall sshd
```



### scp

cp命令来自于英文词组“secure copy”的缩写，其功能是用于基于SSH协议远程拷贝文件。scp命令可以在多台Linux系统之间复制文件或目录 ，有些类似于cp命令的功能，但复制的范围却不是本地，而是网络上另一台主机。

由于是基于SSH协议进行的复制操作，全部数据都是加密的，因此会比HTTP和FTP更加安全。

```
scp 参数 文件
```

| -1   | 使用ssh协议版本1-2                     |
| ---- | -------------------------------------- |
| -2   | 使用ssh协议版本2                       |
| -4   | 使用ipv4                               |
| -6   | 使用ipv6                               |
| -B   | 以批处理模式运行                       |
| -C   | 使用压缩                               |
| -F   | 指定ssh配置文件                        |
| -l   | 指定宽带限制                           |
| -o   | 指定使用的ssh选项                      |
| -P   | 指定远程主机的端口号                   |
| -p   | 保留文件的修改时间，访问时间和权限模式 |
| -q   | 不显示复制进度                         |
| -r   | 以递归方式复制                         |



```
scp -r root@10.10.60.151:/userdata/jenkins/workspace/emtest/soa_test*.xml ./
scp -r root@10.10.60.151:/userdata/jenkins/workspace/emtest/index.txt ./
```

将某个本地文件复制到指定的远程主机的指定目录中：

```
scp anaconda-ks.cfg 192.168.10.10:/root  
```

将指定远程主机中的某个文件复制到本地家目录中：

```
scp 192.168.10.10:/root/anaconda-ks.cfg /root
```

将某个本地目录复制到指定的远程主机的指定目录中：

```
scp -r Documents 192.168.10.10:/root
```

将指定远程主机中的某个目录复制到本地家目录中：

```
scp -r 192.168.10.10:/root/Documents /root
scp -r root@10.10.60.151:/userdata/jenkins/workspace ./
```

将某个本地文件复制到指定的远程主机的指定目录中，指定要使用的传输用户身份，并保留原始文件的权限属性。

```
scp -p anaconda-ks.cfg linuxprobe@192.168.10.10:/root
```





## 系统状态监测命令

### ifconfig

ifconfig命令用于获取网卡配置与网络状态等信息，英文全称为“interface config”，语法格式为“ifconfig [参数] [网络设备]”。

使用ifconfig命令来查看本机当前的网卡配置与网络状态等信息时，其实主要查看的就是网卡名称、inet参数后面的IP地址、ether参数后面的网卡物理地址（又称为MAC地址），以及RX、TX的接收数据包与发送数据包的个数及累计流量（即下面加粗的信息内容）：



### uname

uname命令用于查看系统内核版本与系统架构等信息，英文全称为“unix name”，语法格式为“uname [-a]”。

在使用uname命令时，一般要固定搭配上-a参数来完整地查看当前系统的内核名称、主机名、内核发行版本、节点名、压制时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息：

```bash
uname -a

cat /etc/redhat-release		# 查看当前系统版本的详细信息
```



### uptime

uptime命令用于查看系统的负载信息，输入该命令后按回车键执行即可。

uptime命令真的很棒，它可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息。平均负载值指的是系统在最近1分钟、5分钟、15分钟内的压力情况（下面加粗的信息部分），负载值越低越好：

> “负载值越低越好”是对运维人员来讲的，越低表示越安全省心。但是公司购置的硬件设备如果长期处于空闲状态，则明显是种资源浪费，老板也不会开心。所以建议负载值保持在1左右，在生产环境中不要超过5就好。



### free

free命令用于显示当前系统中内存的使用量信息，语法格式为“free [-h]”。

为了保证Linux系统不会因资源耗尽而突然宕机，运维人员需要时刻关注内存的使用量。在使用free命令时，可以结合使用-h参数以更人性化的方式输出当前内存的实时使用量信息。

| 内存总量 | 已用量 | 空闲量 | 进程共享的内存量 | 磁盘缓存的内存量 | 缓存的内存量 | 可用量    |
| -------- | ------ | ------ | ---------------- | ---------------- | ------------ | --------- |
| total    | used   | free   | shared           | buffers          | buff/cache   | available |

如果不使用-h（易读模式）查看内存使用量情况，则默认以KB为单位。



### who

who命令用于查看当前登入主机的用户终端信息，这3个简单的字母可以快速显示出所有正在登录本机的用户名称以及他们正在开启的终端信息；如果有远程用户，还会显示出来访者的IP地址。

| 登陆的用户名 | 终端设备 | 登陆到系统的时间        |
| ------------ | -------- | ----------------------- |
| root         | tty2     | 2020-07-24 06:26 (tty2) |

### last

last命令用于调取主机的被访记录。Linux系统会将每次的登录信息都记录到日志文件中

### ping

执行ping命令时，系统会使用ICMP向远端主机发出要求回应的信息，若连接远端主机的网络没有问题，远端主机会回应该信息。

```bash
ping -c 4 qiuyeyijian.com		# -c 表示请求次数
```

### tracepath

tracepath命令用于显示数据包到达目的主机时途中经过的所有路由信息，语法格式为“tracepath [参数] 域名”。

当两台主机之间无法正常ping通时，要考虑两台主机之间是否有错误的路由信息，导致数据被某一台设备错误地丢弃。这时便可以使用tracepath命令追踪数据包到达目的主机时途中的所有路由信息，以分析是哪台设备出了问题。

### netstat

netstat命令用于显示如网络连接、路由表、接口状态等的网络相关信息，英文全称为“network status”，语法格式为“netstat [参数]”。

| -a   | 显示所有连接中的Socket   |
| ---- | ------------------------ |
| -p   | 显示正在使用的Socket信息 |
| -t   | 显示TCP协议的连接状态    |
| -u   | 显示UDP协议的连接状态    |
| -n   | 使用IP地址，不使用域名   |
| -l   | 仅列出正在监听的服务状态 |
| -i   | 显示网卡列表信息         |
| -r   | 显示路由表信息           |





### history

history命令用于显示执行过的命令历史，语法格式为“history [-c]”。

history命令应该是运维人员最喜欢的命令。执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，可以自定义/etc/profile文件中的HISTSIZE变量值。在使用history命令时，可以使用-c参数清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。

历史命令会被保存到用户家目录中的.bash_history文件中。Linux系统中以点（.）开头的文件均代表隐藏文件，这些文件大多数为系统服务文件，可以用cat命令查看其文件内容：

```bash
cat ~/.bash_history
```

要清空当前用户在本机上执行的Linux命令历史记录信息，可执行如下命令：

```bash
history -c
```



### sos report

sosreport命令用于收集系统配置及架构信息并输出诊断文档，输入该命令后按回车键执行即可。

当Linux系统出现故障需要联系技术支持人员时，大多数时候都要先使用这个命令来简单收集系统的运行状态和服务配置信息，以便让技术支持人员能够远程解决一些小问题，抑或让他们能提前了解某些复杂问题。



### df

df 以磁盘分区为单位查看文件系统，可以获取硬盘被占用了多少空间，目前还剩下多少空间等信息。

例如，我们使用**df -h**命令来查看磁盘信息， **-h** 选项为根据大小适当显示：

- **Filesystem**：文件系统
- **Size**： 分区大小
- **Used**： 已使用容量
- **Avail**： 还可以使用的容量
- **Use%**： 已用百分比
- **Mounted on**： 挂载点　

- **df -hl**：查看磁盘剩余空间
- **df -h**：查看每个根路径的分区大小
- **du -sh [目录名]**：返回该目录的大小
- **du -sm [文件夹]**：返回该文件夹总M数
- **du -h [目录名]**：查看指定文件夹下的所有文件大小（包含子文件夹）



### du

**du** 的英文原义为 **disk usage**，含义为显示磁盘空间的使用情况，用于查看当前目录的总大小。

例如查看当前目录的大小：

```bash
# du -sh
605M    .
```

```bash
# du -h test		方便阅读的格式显示test目录所占空间情况：
```

du 命令用于查看当前目录的总大小：

- **-s**：对每个Names参数只给出占用的数据块总数。
- **-a**：递归地显示指定目录中各文件及子目录中各文件占用的数据块数。若既不指定-s，也不指定-a，则只显示Names中的每一个目录及其中的各子目录所占的磁盘块数。
- **-b**：以字节为单位列出磁盘空间使用情况（系统默认以k字节为单位）。
- **-k**：以1024字节为单位列出磁盘空间使用情况。
- **-c**：最后再加上一个总计（系统默认设置）。
- **-l**：计算所有的文件大小，对硬链接文件，则计算多次。
- **-x**：跳过在不同文件系统上的目录不予统计。
- **-h**：以K，M，G为单位，提高信息的可读性。

## 查找定位文件命令

### pwd

pwd命令用于显示用户当前所处的工作目录，英文全称为“print working directory”

### cd

cd命令用于切换当前的工作路径，英文全称为“change directory”

```bash
cd -		# 返回上次所处目录
cd ..		# 返回上级目录
cd ~		# 返回当前用户家目录
cd ~username	# 返回其他用户家目录
```

### ls

ls命令用于显示目录中的文件信息，英文全称为“list”

```bash
ls [-l -i -d -a] # -l：显示详细信息, -d: 显示该目录的信息 -a参数可以看到全部文件（包括隐藏文件）
ls -la			 # 查看当前目录所有文件详细信息
ls -ld /work	 # 查看work目录详细信息
```





### tree

tree命令用于以树状图的形式列出目录内容及结构

### find

find命令用于按照指定条件来查找文件所对应的位置，语法格式为“find [查找范围] 寻找条件”。

本书中会多次提到“Linux系统中的一切都是文件”，接下来就要见证这句话的分量了。在Linux系统中，搜索工作一般都是通过find命令来完成的，它可以使用不同的文件特性作为寻找条件（如文件名、大小、修改时间、权限等信息），一旦匹配成功则默认将信息显示到屏幕上。

这里需要重点讲解-exec参数的重要作用。这个参数用于把find命令搜索到的结果交由紧随其后的命令作进一步处理。它十分类似管道符技术，并且由于find命令对参数有特殊要求，因此虽然exec是长格式形式，但它的前面依然只需要一个减号（-）。

| 参数              | 作用                                                         |
| ----------------- | ------------------------------------------------------------ |
| -name             | 匹配名称                                                     |
| -perm             | 匹配权限（mode为完全匹配，-mode为包含即可）                  |
| -user             | 匹配所有者                                                   |
| -group            | 匹配所有组                                                   |
| -mtime -n +n      | 匹配修改内容的时间（-n指n天以内，+n指n天以前）               |
| -atime -n +n      | 匹配访问文件的时间（-n指n天以内，+n指n天以前）               |
| -ctime -n +n      | 匹配修改文件权限的时间（-n指n天以内，+n指n天以前）           |
| -nouser           | 匹配无所有者的文件                                           |
| -nogroup          | 匹配无所有组的文件                                           |
| -newer f1 !f2     | 匹配比文件f1新但比f2旧的文件                                 |
| -type b/d/c/p/l/f | 匹配文件类型（后面的字幕字母依次表示块设备、目录、字符设备、管道、链接文件、文本文件） |
| -size             | 匹配文件的大小（+50KB为查找超过50KB的文件，而-50KB为查找小于50KB的文件） |
| -prune            | 忽略某个目录                                                 |
| -exec …… {}\;     | 后面可跟用于进一步处理搜索结果的命令（下文会有演示）         |



```shell
find /etc -name "host*"

find ./ -name *.txt -exec mv {} ./ \;
```

```shell
-exec 后面跟着命令，以分号结束。分号前面加上反斜杠\，防止终端将分号解释成其他意思。
{} 表示find搜索出的每一个文件，中间不能有空格
```



### locate

locate命令用于按照名称快速搜索文件所对应的位置，语法格式为“locate文件名称”。

使用find命令进行全盘搜索虽然更准确，但是效率有点低。如果仅仅是想找一些常见的且又知道大概名称的文件，不如试试locate命令。在使用locate命令时，先使用updatedb命令生成一个索引库文件，这个库文件的名字是/var/lib/mlocate/mlocate.db，后续在使用locate命令搜索文件时就是在该库中进行查找操作，速度会快很多。

```bash
updatedb			# 生成索引

locate git			# 查找名为git的文件位置
```



### whereis

whereis命令用于按照名称快速搜索二进制程序（命令）、源代码以及帮助文件所对应的位置，语法格式为“whereis命令名称”。

简单来说，whereis命令也是基于updatedb命令所生成的索引库文件进行搜索，它与locate命令的区别是不关心那些相同名称的文件，**仅仅是快速找到对应的命令文件及其帮助文件所在的位置。**

```bash
whereis pwd
whereis ls
```



### which

which命令用于按照指定名称快速搜索二进制程序（命令）所对应的位置，语法格式为“which命令名称”。

which命令是在PATH变量所指定的路径中，按照指定条件搜索命令所在的路径。也就是说，如果我们既不关心同名文件（find与locate），也不关心命令所对应的源代码和帮助文件（whereis），仅仅是想找到命令本身所在的路径，那么这个which命令就太合适了。

```bash
which ls
```



## 文本编辑命令

### cat

cat命令用于查看纯文本文件（内容较少的），英文全称为**concatenate**，语法格式为“cat [参数] 文件名称”。

```bash
cat -n test.txt			# -n 显示行号
```



### nl

`nl`命令在`Linux`系统中用来计算文件的行号,是 **number of lines** 的缩写。`nl`可以将输出的文件自动加上行号！其默认的结果与`cat -n`有点不太一样,`nl`可以自定义行号显示效果,包括位数和自动补全0

nl 命令读取 File 参数（缺省情况下标准输入），计算输入中的行号，将计算过的行号写入标准输出。 在输出中，nl 命令根据您在命令行中指定的标志来计算左边的行。 输入文本必须写在逻辑页中。每个逻辑页有头、主体和页脚节（可以有空节）。 除非使用 -p 标志，nl 命令在每个逻辑页开始的地方重新设置行号。 可以单独为头、主体和页脚节设置行计算标志（例如，头和页脚行可以被计算然而文本行不能）。

```bash
nl [选项] [文件]
```

| 选项    | 含义                               |
| ------- | ---------------------------------- |
| `-b a`  | 无论是否是空行都列出行号           |
| `-b t`  | 空行不列出行号(默认)               |
| `-n ln` | 行号在显示栏的最左边显示           |
| `-n rn` | 行号在显示栏的最右边显示,不填充0   |
| `-n rz` | 行号在显示栏的最右边显示(默认)     |
| `-w`    | 行号显示栏占用的位数,(默认是6位)。 |
| `-p`    | 在逻辑定界符处不重新开始计算       |



```bash
nl test.txt		# 显示文件内容，列出行号(不包括空行)
nl -b a test.txt		# 显示文件内容，列出行号(包括空行)
nl -b a -n rz test.txt		# 显示文件内容，列出行号(包括空行)，行号前面填充0
nl -b a -n rz -w 3 test.txt	# 显示文件内容，列出行号(包括空行)，行号前面填充0，行号占3位
nl -s :: test.txt			# 定制的编号分隔符 ::
```



### more

more命令用于查看纯文本文件（内容较多的），语法格式为“more [参数] 文件名称”。

如果需要阅读长篇小说或者非常长的配置文件，那么“小猫咪”可就真的不适合了。



### head

head命令用于查看纯文本文件的前*N*行，语法格式为“head [参数] 文件名称”。

```bash
head -n 10 test.txt
```



### tail

tail命令用于查看纯文本文件的后*N*行或持续刷新文件的最新内容，语法格式为“tail [参数] 文件名称”。

```bash
tail -n 10 test.txt
```

tail命令最强悍的功能是能够持续刷新一个文件的内容，当想要实时查看最新的日志文件时，这特别有用，此时的命令格式为“tail -f文件名称”：

```bash
tail -f /var/log/messages
```



### tr

tr命令用于替换文本内容中的字符，英文全称为“transform”，语法格式为“tr [原始字符] [目标字符]”。

在很多时候，我们想要快速地替换文本中的一些词汇，又或者想把整个文本内容都进行替换。如果进行手工替换，难免工作量太大，尤其是需要处理大批量的内容时，进行手工替换更是不现实。这时，就可以先使用cat命令读取待处理的文本，然后通过管道符把这些文本内容传递给tr命令进行替换操作即可

```bash
cat 1.txt | tr [a-z] [A-Z] > 2.txt		# 将1.txt中小写字母替换成大写，结果保存自2.txt中
```



### wc

wc命令用于统计指定文本文件的行数、字数或字节数，英文全称为“word counts”，语法格式为“wc [参数] 文件名称”。

每次我在课堂上讲到这个命令时，总有同学会联想到一种公共设施，其实这两者毫无关联。wc命令用于统计文本的行数、字数、字节数等。

| 参数 | 作用         |
| ---- | ------------ |
| -l   | 只显示行数   |
| -w   | 只显示单词数 |
| -c   | 只显示字节数 |

```bash
wc -l /etc/passwd			# 每一行代表一个用户
```





### stat

stat命令用于查看文件的具体存储细节和时间等信息，英文全称为“status”，语法格式为“stat文件名称”。

大家都知道，文件有一个修改时间。其实，除了修改时间之外，Linux系统中的文件包含3种时间状态，分别是Access Time（内容最后一次被访问的时间，简称为Atime），Modify Time（内容最后一次被修改的时间，简称为Mtime）以及Change Time（文件属性最后一次被修改的时间，简称为Ctime）。

```bash
stat test.txt
```



### grep

grep是“global search regular expression and print out the line”的简称，意思是全面搜索正则表达式，并将其打印出来。这个命令可以结合正则表达式使用，它也是linux使用最为广泛的命令。

grep命令用于按行提取文本内容，语法格式为“grep [参数] 文件名称”。

| 参数 | 作用                                           |
| ---- | ---------------------------------------------- |
| -b   | 将可执行文件(binary)当作文本文件（text）来搜索 |
| -c   | 仅显示找到的行数                               |
| -i   | 忽略大小写                                     |
| -n   | 显示行号                                       |
| -v   | 反向选择——仅列出没有“关键词”的行。             |

```bash
grep /sbin/nologin /etc/passwd 		# 查找出当前系统中不允许登录系统的所有用户的信息
```



### cut

cut命令用于按“列”提取文本内容，语法格式为“cut [参数] 文件名称”。

```bash
cut -d : -f 1 /etc/passwd		# 提取出passwd文件中的用户名信息
```

> -d 设置分割符
>
> -f 设置需要查看第几列



### diff

diff命令用于比较多个文件之间内容的差异，英文全称为“different”，语法格式为“diff [参数] 文件名称A 文件名称B”。

在使用diff命令时，不仅可以使用--brief参数来确认两个文件是否相同，还可以使用-c参数来详细比较出多个文件的差异之处。这绝对是判断文件是否被篡改的有力神器。

```bash
diff -c 1.txt 2.txt
```



### uniq

uniq命令用于去除文本中连续的重复行，英文全称为“unique”，语法格式为“uniq [参数] 文件名称”。

能够去除连续的空行、连续的相邻重复行

```bash
uniq 1.txt
```



### sort

sort命令用于对文本内容进行再排序，语法格式为“sort [参数] 文件名称”。默认按照字母排序

| 参数 | 作用           |
| ---- | -------------- |
| -f   | 忽略大小写     |
| -b   | 忽略缩进与空格 |
| -n   | 以数值型排序   |
| -r   | 反向排序       |
| -u   | 去除重复行     |
| -t   | 指定间隔符     |
| -k   | 设置字段范围   |

此外，与uniq命令不同，sort命令是无论内容行之间是否夹杂有其他内容，只要有两个一模一样的内容行，立马就可以使用-u参数进行去重操作

```bash
cut -d : -f 1 /etc/passwd > 1.txt

sort -u 1.txt
```

以第3个字段中的数字作为排序依据，那么可以用-t参数指定间隔符，用-k参数指定第几列，用-n参数进行数字排序来搞定：

```bash
head -n 10 /etc/passwd > 1.txt

sort -t : -k 3 -n 1.txt
```





## 文件目录管理命令

### touch

touch命令用于创建空白文件或设置文件的时间，语法格式为“touch [参数] 文件名称”。

在创建空白的文本文件方面，这个touch命令相当简洁，简捷到没有必要铺开去讲。比如，touch linuxprobe命令可以创建出一个名为linuxprobe的空白文本文件。对touch命令来讲，有难度的操作主要是体现在设置文件内容的修改时间（Mtime）、文件权限或属性的更改时间（Ctime）与文件的访问时间（Atime）上面。

| 参数 | 作用                      |
| ---- | ------------------------- |
| -a   | 仅修改“读取时间”（atime） |
| -m   | 仅修改“修改时间”（mtime） |
| -d   | 同时修改atime与mtime      |

```bash
ls -l 1.txt		# -rw-r--r--. 1 root root 385 2月  25 14:57 1.txt
# 几分钟后
echo "Hello, world" >> 1.txt
ls -l 1.txt		# -rw-r--r--. 1 root root 398 2月  25 15:10 1.txt

touch -d "2022-2-25 14:57" 1.txt		# 修改文件时间属性
ls -l 1.txt		# -rw-r--r--. 1 root root 385 2月  25 14:57 1.txt
```



### cp、mv、rm、mkdir、file

```bash
cp [-f -i -r] 源文件 目标文件	# copy，-f : 强制覆盖重名文件，不询问。-i: 询问。-r: 递归拷贝，用于目录
mv [-f -i] 源文件 目标文件		# move
rm [-f -i -r]				 # remove
mkdir [-p]					# 创建多级目录,make directory
rmdir [-p]					# 删除多级目录
file 文件名				  # 显示文件类型
```



### dd

dd命令用于按照指定大小和个数的数据块来复制文件或转换文件，语法格式为“dd if=参数值of=参数值count=参数值bs=参数值”。

dd命令是一个比较重要而且比较有特色的命令，它能够让用户按照指定大小和个数的数据块来复制文件的内容。当然，如果愿意的话，还可以在复制过程中转换其中的数据。

Linux系统中有一个名为/dev/zero的设备文件，每次在课堂上解释它时都充满哲学理论的色彩。因为这个文件不会占用系统存储空间，但却可以提供无穷无尽的数据，因此常常使用它作为dd命令的输入文件，来生成一个指定大小的文件。

| 参数  | 作用                 |
| ----- | -------------------- |
| if    | 输入的文件名称       |
| of    | 输出的文件名称       |
| bs    | 设置每个“块”的大小   |
| count | 设置要复制“块”的个数 |

```bash
dd if=/dev/zero of=1.txt count=1 bs=560M	# 生成一个名为1.txt的560M大小的文件
```

dd命令的功能也绝不仅限于复制文件这么简单。如果想把光驱设备中的光盘制作成iso格式的镜像文件，在Windows系统中需要借助于第三方软件才能做到，但在Linux系统中可以直接使用dd命令来压制出光盘镜像文件，将它变成一个可立即使用的iso镜像：

```bash
dd if=/dev/cdrom of=linux.iso		# 实验证明可以作为虚拟机安装镜像!
```



### tar

tar.gz这种格式是Linux下使用得最多的压缩格式。它在压缩时不会占用太多CPU的，而且可以得到一个非常理想的压缩率。

首先，-c参数用于创建压缩文件，-x参数用于解压文件，因此这两个参数不能同时使用。

其次，-z参数指定使用gzip格式来压缩或解压文件，-j参数指定使用bzip2格式来压缩或解压文件。用户使用时则是根据文件的后缀来决定应使用何种格式的参数进行解压。

在执行某些压缩或解压操作时，可能需要花费数个小时，如果屏幕一直没有输出，您一方面不好判断打包的进度情况，另一方面也会怀疑电脑死机了，因此非常推荐使用-v参数向用户不断显示压缩或解压的过程。

-C参数用于指定要解压到哪个指定的目录。

-f参数特别重要，它必须放到参数的最后一位，代表要压缩或解压的软件包名称。

```
tar [选项] [源文件或目录]
```

```shell
-z 压缩和解压缩 ".tar.gz" 格式；
-x 对tar包做解打包操作。
-c 将多个文件或目录进行打包。
-v 显示打包文件过程；
-f 包名，指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名；

-A 追加tar文件到归档文件。
-t 只查看tar包中有哪些文件或目录，不对tar包做解打包操作。
-C 目录指定解打包位置。
-j 压缩和解压缩 ".tar.bz2"格式。
```

```bash
tar -czvf filename.tar.gz [directory]				//压缩一个目录
tar -xzvf filename.tar.gz							//解压缩到当前文件夹
tar -xzvf filename.tar.gz -C /usr/temp/				//解压缩到指定目录下
```

> 归档：也称为打包，指的是一个文件或目录的集合，而这个集合被存储在一个文件中。归档文件没有经过压缩，因此，它占用的空间是其中所有文件和目录的总和。
>
> 压缩：压缩文件也是一个文件和目录的集合，且这个集合也被存储在一个文件中，但它们的不同之处在于，**压缩文件采用了不同的存储方式，使其所占用的磁盘空间比集合中所有文件大小的总和要小。**

> 如果使用`tar -zxvf`出现`gzip: stdin: not in gzip format`错误，说明压缩包不是`.tar.gz`格式的，可以去掉`z`参数，使用`tar -xvf`解压







# 文本处理命令

## 一些linux命令积累——字符串处理相关

https://blog.csdn.net/LoseInVain/article/details/120272575