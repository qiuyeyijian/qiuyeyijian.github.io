import{_ as e,v as a,b as r,R as t}from"./chunks/framework.53249f15.js";const O=JSON.parse('{"title":"IO多路复用","description":"","frontmatter":{},"headers":[],"relativePath":"articles/Linux/网络编程/IO多路复用/README.md","filePath":"articles/Linux/网络编程/IO多路复用/README.md"}'),l={name:"articles/Linux/网络编程/IO多路复用/README.md"},i=t('<h1 id="io多路复用" tabindex="-1">IO多路复用 <a class="header-anchor" href="#io多路复用" aria-label="Permalink to &quot;IO多路复用&quot;">​</a></h1><p>IO 多路转接也称为 IO 多路复用，它是一种网络通信的手段（机制），通过这种方式可以同时监测多个文件描述符并且这个过程是阻塞的，一旦检测到有文件描述符就绪（ 可以读数据或者可以写数据）程序的阻塞就会被解除，之后就可以基于这些（一个或多个）就绪的文件描述符进行通信了。**通过这种方式在单线程 / 进程的场景下也可以在服务器端实现并发。**常见的 IO 多路转接方式有：select、poll、epoll。</p><p>下面先对多线程 / 多进程并发和 IO 多路转接的并发处理流程进行对比（服务器端）。</p><h2 id="多线程-多进程并发" tabindex="-1">多线程 / 多进程并发 <a class="header-anchor" href="#多线程-多进程并发" aria-label="Permalink to &quot;多线程 / 多进程并发&quot;">​</a></h2><p>主线程 / 父进程：调用 accept() 监测客户端连接请求</p><ul><li>如果没有新的客户端的连接请求，当前线程 / 进程会阻塞</li><li>如果有新的客户端连接请求解除阻塞，建立连接</li></ul><p>子线程 / 子进程：和建立连接的客户端通信</p><ul><li>调用 read() / recv() 接收客户端发送的通信数据，如果没有通信数据，当前线程 / 进程会阻塞，数据到达之后阻塞自动解除</li><li>调用 write() / send() 给客户端发送数据，如果写缓冲区已满，当前线程 / 进程会阻塞，否则将待发送数据写入写缓冲区中</li></ul><h2 id="io-多路转接并发" tabindex="-1">IO 多路转接并发 <a class="header-anchor" href="#io-多路转接并发" aria-label="Permalink to &quot;IO 多路转接并发&quot;">​</a></h2><p>使用 IO 多路转接函数委托内核检测服务器端所有的文件描述符（通信和监听两类），这个检测过程会导致进程 / 线程的阻塞，如果检测到已就绪的文件描述符阻塞解除，并将这些已就绪的文件描述符传出</p><p>根据类型对传出的所有已就绪文件描述符进行判断，并做出不同的处理</p><p>监听的文件描述符：和客户端建立连接</p><p>此时调用 accept() 是不会导致程序阻塞的，因为监听的文件描述符是已就绪的（有新请求）</p><p>通信的文件描述符：调用通信函数和已建立连接的客户端通信</p><p>调用 read() / recv() 不会阻塞程序，因为通信的文件描述符是就绪的，读缓冲区内已有数据</p><p>调用 write() / send() 不会阻塞程序，因为通信的文件描述符是就绪的，写缓冲区不满，可以往里面写数据</p><p>对这些文件描述符继续进行下一轮的检测（循环往复。。。）</p><p>与多进程和多线程技术相比，I/O 多路复用技术的最大优势是系统开销小，系统不必创建进程 / 线程，也不必维护这些进程 / 线程，从而大大减小了系统的开销。</p><h2 id="reference" tabindex="-1">Reference <a class="header-anchor" href="#reference" aria-label="Permalink to &quot;Reference&quot;">​</a></h2><p><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noreferrer">Linux IO模式及 select、poll、epoll详解</a></p>',20),p=[i];function o(n,s,c,d,h,u){return a(),r("div",null,p)}const _=e(l,[["render",o]]);export{O as __pageData,_ as default};
