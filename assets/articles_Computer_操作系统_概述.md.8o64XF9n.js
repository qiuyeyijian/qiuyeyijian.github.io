import{_ as t,o as a,c as r,R as e}from"./chunks/framework.UjU5Kp2a.js";const o="/assets/5822251-f4fdfc3425ffc9f0.7usvDy6U.png",n="/assets/20140702173406812.rMwDdpSU.jpg",s="/assets/20190328033643556.Plu1tW85.png",f=JSON.parse('{"title":"概述","description":"","frontmatter":{},"headers":[],"relativePath":"articles/Computer/操作系统/概述.md","filePath":"articles/Computer/操作系统/概述.md"}'),p={name:"articles/Computer/操作系统/概述.md"},l=e('<h1 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h1><h2 id="操作系统基本概念" tabindex="-1">操作系统基本概念 <a class="header-anchor" href="#操作系统基本概念" aria-label="Permalink to &quot;操作系统基本概念&quot;">​</a></h2><p><strong>操作系统（Operating System，OS）<strong>是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的</strong>系统软件</strong></p><blockquote><p>简单来说，有三个方面</p><ol><li>负责管理协调硬件，软件等<strong>计算机资源</strong>的工作</li><li>为上层应用程序、用户提供简单易用的服务</li><li>操作系统是<strong>系统软件</strong>，而不是硬件</li></ol></blockquote><h3 id="操作系统的特征" tabindex="-1">操作系统的特征 <a class="header-anchor" href="#操作系统的特征" aria-label="Permalink to &quot;操作系统的特征&quot;">​</a></h3><p><strong>并发，共享，虚拟，异步</strong>是操作系统的四个基本特征。其中<strong>并发和共享是两个最基本的特征</strong>，二者互为存在条件。</p><p><strong>并发</strong>：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的</p><p><strong>并行</strong>：指两个或多个时间在同一时刻同时发生。</p><p><strong>共享：</strong> 即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。<strong>互斥共享和同时共享</strong>是两种资源共享方式。</p><p>所谓“同时”往往是宏观上的，而微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）</p><p><strong>虚拟：</strong> 是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际上存在的，而逻辑上对应物（后者）是用户感受到的。</p><p>虚拟技术包括“空分复用技术”和“时分复用技术”</p><h3 id="操作系统的基本类型" tabindex="-1">操作系统的基本类型 <a class="header-anchor" href="#操作系统的基本类型" aria-label="Permalink to &quot;操作系统的基本类型&quot;">​</a></h3><p><strong>批处理操作系统</strong>：采用批处理方式工作的操作系统</p><p><strong>分时操作系统</strong>：通过把处理器的时间划分成时间片并轮流 为各个用户服务的方式工作的操作系统</p><p><strong>实时操作系统</strong>：能够对外部事件或数据进行及时接受和处理，并做出反馈</p><h3 id="多道程序基本概念" tabindex="-1">多道程序基本概念 <a class="header-anchor" href="#多道程序基本概念" aria-label="Permalink to &quot;多道程序基本概念&quot;">​</a></h3><p><strong>多道程序设计</strong>是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制之下，相互穿插的运行。两个或两个以上程序在计算机系统中同处于开始到结束之间的状态。这就称为多道程序设计。</p><p>多道程序技术运行的特征：多道、宏观上并行、微观上串行。多道程序设计的出现，加快了OS的诞生。<strong>多道程序设计的基本特征：间断性、共享性、制约性。</strong></p><p>程序的封闭性是指进程执行的结果只取决于进程本身，不受外界影响。</p><h3 id="操作系统提供的接口" tabindex="-1">操作系统提供的接口 <a class="header-anchor" href="#操作系统提供的接口" aria-label="Permalink to &quot;操作系统提供的接口&quot;">​</a></h3><p>操作系统提供的接口主要分为两类：命令接口和程序接口。命令接口分为联机命令接口和脱机命令接口。程序接口由一组**系统调用（也称广义指令）**组成。</p><p>联机命令接口又称为交互式命令接口，适用于分时或实时操作系统。脱机命令接口又称为批处理命令接口，适用于批处理系统。</p><p><strong>系统调用是操作系统为应用程序使用内核功能所提供的接口。</strong></p><p><img src="'+o+'" alt="img"></p><p>库函数是编程语言或应用程序的一部分，目的是隐藏“访管”指令细节，简化操作，运行在用户空间中。系统调用是操作系统的一部分，是内核为用户提供的程序接口，运行在内核空间中。</p><p>许多库函数都会使用系统调用来实现功能。未使用系统调用的库函数，其执行效率通常比系统调用高。因为使用系统调用时，需要进行上下文切换（由用户态转向核心态）。</p><h3 id="单-宏-内核与微内核" tabindex="-1">单（宏）内核与微内核 <a class="header-anchor" href="#单-宏-内核与微内核" aria-label="Permalink to &quot;单（宏）内核与微内核&quot;">​</a></h3><p>单内核即Monokernel（全称：Monolithic kernel）。也被译作宏内核，大内核。个人感觉宏内核一词可能让人不明就里，以下都称单内核。Linux正基于单内核，这是比较古老的内核架构。内核提供多项服务，我们常用的文件IO、内存管理、网络相关的系统调用全部运行在内核态，都运行在同一地址空间之中。</p><p>微内核即Microkernel（简写：μ-kernel）提出时间比单内核要晚，在学术界而言无疑是初生的朝阳。微内核基于模块化的设计，将内核功能简化到最少，仅提供少量基础功能，更多的功能运行在用户态，不同服务运行在不同的地址空间，常用的服务（比如IO、内存管理）通过IPC调用来组合提供。无疑从这个层面上讲微内核的扩展性更强，增加新功能无需重新编译内核。并且由于内核服务间的隔离，使得OS更安全，一个服务挂掉，不会影响其他服务。而单内核中一个服务的异常可能让整个内核挂掉。但问题也显而易见，那就是大量的IPC，性能必然受影响。</p><p><a href="https://www.cnblogs.com/yeahwell/p/5226047.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/yeahwell/p/5226047.html</a></p><h3 id="内核态与用户态" tabindex="-1">内核态与用户态 <a class="header-anchor" href="#内核态与用户态" aria-label="Permalink to &quot;内核态与用户态&quot;">​</a></h3><p>用户态到核心态是通过中断来实现的，并且中断是唯一的途径。</p><p>不管是单内核还是微内核，运行在用户态的应用程序，想使用某些内核态才能执行的功能，必须要经过系统调用来实现。所以你需要明白：<strong>进程从用户态陷入了内核态，这是目的，而使用系统调用，仅仅是达成该目的的手段。因果要理清。</strong></p><p>系统调用可以在用户态下发生，但只能在核心态下执行。</p><p>用户态转向核心态的例子：</p><ul><li>系统调用</li><li>发生一次中断，发生外中断</li><li>用户程序错误，发生内中断</li><li>用户程序企图执行一条特权指令，发生访管中断。</li></ul><p>核心态到用户态的切换时通过执行一个特权指令，将程序状态字（psw）的标志位设置为“用户态”</p><p>访管指令是在用户态下执行，通过访管指令发生访管中断，它不是特权指令。核心态下可以执行除了访管指令外的一切指令。</p><h3 id="中断和异常" tabindex="-1">中断和异常 <a class="header-anchor" href="#中断和异常" aria-label="Permalink to &quot;中断和异常&quot;">​</a></h3><p><img src="'+n+'" alt="img"></p><blockquote><p>**中断（Interruption）**是指 CPU 对系统发生某事件时的这样一种响应。CPU 暂停正在执行的程序，在保留现场后自动地转去执行该事件的中断处理程序；执行完后，再返回到原程序的断点处继续执行。</p></blockquote><p>还可进一步把中断分为外中断和内中断。</p><ul><li><strong>外中断</strong>，是指由于外部设备事件所引起的中断，如通常的磁盘中断、打印机中断等。也就是CPU正忙着自己的事情，突然被别人打扰让帮忙处理一些事情。</li><li><strong>内中断，就是异常</strong>，是指由于 CPU 内部事件所引起的中断，如程序非法操作码、地址越界、算术溢出、虚存系统缺页和专门的陷入指令等。内中断(trap)也被译为“捕获”或“陷入”。也就是CPU自己做了一些不该做的事情，把一切搞砸了。</li></ul><p><img src="'+s+'" alt="img"></p><p>异常是由于执行了现行指令所引起的。由于系统调用引起的中断属于异常。中断则是由于系统中某事件引起的，该事件与现行指令无关。</p><p>平时一般所说的中断默认指外中断，因为内中断也就是异常一旦反生就代表出错了。</p><p>再来解释一下什么是软中断。要说软中断，先说一下中断（interrupt），中断本身是一个硬件概念，就是打断CPU，让其执行一下其他任务，比如键盘中断、打印机中断、定时器中断等。软中断本就是从软件层面模拟了这一中断操作。</p><h3 id="保护现场" tabindex="-1">保护现场 <a class="header-anchor" href="#保护现场" aria-label="Permalink to &quot;保护现场&quot;">​</a></h3><p>保护现场有两个含义：第一是保存程序的断点，一般指PC和PSWR由中断隐指令（硬件）自动完成。第二是保存通用寄存器的内容，由中断服务程序完成。</p><h2 id="术语拓展" tabindex="-1">术语拓展 <a class="header-anchor" href="#术语拓展" aria-label="Permalink to &quot;术语拓展&quot;">​</a></h2><p>可重入代码(Reentry code)也叫<a href="https://baike.baidu.com/item/%E7%BA%AF%E4%BB%A3%E7%A0%81/5669644" target="_blank" rel="noreferrer">纯代码</a>(Pure code)是一种允许多个进程同时访问的代码。为了使各进程所执行的代码完全相同，故不允许任何进程对其进行修改。<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F/71525" target="_blank" rel="noreferrer">程序</a>在运行过程中可以被打断，并由开始处再次执行，并且在合理的范围内（多次重入，而不造成<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88%E6%BA%A2%E5%87%BA/1231765" target="_blank" rel="noreferrer">堆栈溢出</a>等其他问题），程序可以在被打断处继续执行，且执行结果不受影响。</p><p>通常是不含有静态变量static的函数。</p>',53),i=[l];function h(c,g,d,u,m,_){return a(),r("div",null,i)}const k=t(p,[["render",h]]);export{f as __pageData,k as default};
