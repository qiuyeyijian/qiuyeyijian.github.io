import{_ as t,o as a,c as e,R as r}from"./chunks/framework.UjU5Kp2a.js";const o="/assets/image-20211031145623733.wozL2eh8.png",p="/assets/e9718d128b774804a82b03c253ef67bf.RRyIlLyA.png",i="/assets/image-20210927193426642.gzRlJgcQ.png",Q=JSON.parse('{"title":"数据链路层","description":"","frontmatter":{},"headers":[],"relativePath":"articles/Computer/计算机网络/数据链路层.md","filePath":"articles/Computer/计算机网络/数据链路层.md"}'),s={name:"articles/Computer/计算机网络/数据链路层.md"},d=r('<h1 id="数据链路层" tabindex="-1">数据链路层 <a class="header-anchor" href="#数据链路层" aria-label="Permalink to &quot;数据链路层&quot;">​</a></h1><p><img src="'+o+'" alt="image-20211031145623733"></p><h2 id="arq-automatic-repeat-request-自动重传请求" tabindex="-1">ARQ（Automatic Repeat-reQuest，自动重传请求） <a class="header-anchor" href="#arq-automatic-repeat-request-自动重传请求" aria-label="Permalink to &quot;ARQ（Automatic Repeat-reQuest，自动重传请求）&quot;">​</a></h2><p>滑动窗口协议（Sliding Window Protocol）以基于分组的数据传输协议为特征。因此该协议适用于对按顺序传送分组的可靠性要求较高的环境，例如在数据链路层（OSI模型）以及传输控制协议（TCP）中。</p><h3 id="一-arq简介" tabindex="-1">一. ARQ简介 <a class="header-anchor" href="#一-arq简介" aria-label="Permalink to &quot;一. ARQ简介&quot;">​</a></h3><p>ARQ协议，即自动重传请求（Automatic Repeat-reQuest），是OSI模型中的错误纠正协议之一。</p><p>它通过使用<strong>确认和重传</strong>这两个机制，在不可靠服务的基础上实现可靠的信息传输。</p><p>如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。</p><p>重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组</p><p>ARQ包括停止等待ARQ协议和连续ARQ协议</p><p>传统自动重传请求分成为三种，即停止-等待(stop-and-wait）ARQ，后退N帧（go-back-n）ARQ，以及选择重传（selective repeat）ARQ。</p><p>后两种协议是滑动窗口技术与请求重发技术的结合，由于窗口尺寸开到足够大时，帧在线路上可以连续地流动，因此又称其为<strong>连续ARQ</strong>协议。</p><p>三者的区别在于对于出错的数据报文的处理机制不同。三种ARQ协议中，复杂性递增，效率也递增。除了传统的ARQ，还有混合ARQ（Hybrid-ARQ）。</p><blockquote><p>当发送窗口和接收窗口的大小都等于 1时，就是停止等待协议。</p><p>当发送窗口大于1，接收窗口等于1时，就是回退N步协议。</p><p>当发送窗口和接收窗口的大小均大于1时，就是选择重发协议</p></blockquote><p><img src="'+p+'" alt="在这里插入图片描述"></p><p>ARQ是一种可以在不可靠的数据通道上可靠地传输数据的方案，所以其实链路层和传输层都用了ARQ，并不专属某一层。</p><p>并不是一条连接只要有一层用了ARQ，它的上层的通信就是可靠的。因为ARQ只保证使用它的点到点是可靠的，比如数据链路层只保证你和你的路由器通信可靠，你的路由器到小区的路由器通信也可靠， 但是路由器本身会故障，会拥塞丢包，也就是点本身会产生问题。</p><p>所以需要在传输层或者应用层再加一层ARQ保障整条数据通道的可靠性。比如你自己写程序要在应用层通信，但传输层不用tcp想用udp，也可以在你程序里用ARQ协来实现可靠性。</p><h2 id="滑动窗口" tabindex="-1">滑动窗口 <a class="header-anchor" href="#滑动窗口" aria-label="Permalink to &quot;滑动窗口&quot;">​</a></h2><p>ARQ协议分等停ARQ协议和连续ARQ协议，连续ARQ协议了采用滑动窗口方法，又分为后退N帧协议和选择重传协议</p><p>序号为n位，可编码窗口大小为$2^n$</p><ul><li><p>对于后退N帧协议：发送窗口最大为$2^n - 1$，接收窗口为1</p></li><li><p>对于选择重传协议：发送窗口最大为$2^{n-1}$，且$W_T + W_R &lt;= 2^n$，也就是接收窗口最大也为$2^{n-1}$</p></li></ul><h2 id="vlan" tabindex="-1">VLAN <a class="header-anchor" href="#vlan" aria-label="Permalink to &quot;VLAN&quot;">​</a></h2><p><img src="'+i+'" alt="image-20210927193426642"></p><h2 id="_802-11无线局域网" tabindex="-1">802.11无线局域网 <a class="header-anchor" href="#_802-11无线局域网" aria-label="Permalink to &quot;802.11无线局域网&quot;">​</a></h2><p>802.11帧的地址字段常用的两种情况</p><table><thead><tr><th>去往AP</th><th>来自AP</th><th>地址1</th><th>地址2</th><th>地址3</th><th>地址4</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>目的地址</td><td>AP地址</td><td>源地址</td><td></td></tr><tr><td>1</td><td>0</td><td>AP地址</td><td>源地址</td><td>目的地址</td><td></td></tr></tbody></table><p><strong>核心是：地址1：下一跳是谁，谁发的，地址三就是剩下的那一个</strong></p><ul><li>地址1：下一跳是是谁</li><li>地址2：谁发的</li><li>地址3：目的地址、AP地址和源地址剩下的那一个</li></ul>',29),l=[d];function n(c,h,_,A,u,R){return a(),e("div",null,l)}const b=t(s,[["render",n]]);export{Q as __pageData,b as default};
