import{_ as s,c as i,o as a,U as t}from"./chunks/framework.isgf4Vyz.js";const g=JSON.parse('{"title":"线性表","description":"","frontmatter":{},"headers":[],"relativePath":"articles/Computer/数据结构/线性表.md","filePath":"articles/Computer/数据结构/线性表.md"}'),n={name:"articles/Computer/数据结构/线性表.md"},h=t(`<h1 id="线性表" tabindex="-1">线性表 <a class="header-anchor" href="#线性表" aria-label="Permalink to &quot;线性表&quot;">​</a></h1><p>线性表属于逻辑结构。线性表的顺序存储称为顺序表，链式存储称为链表。也就是说，线性表既可以用顺序存储方式实现，又可以用链式存储方式实现。</p><h2 id="顺序表" tabindex="-1">顺序表 <a class="header-anchor" href="#顺序表" aria-label="Permalink to &quot;顺序表&quot;">​</a></h2><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 顺序表中元素类型，这里定义为int</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ElemType;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 定义顺序表的最大长度</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> maxn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SqList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ElemType data[maxn];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 顺序表当前长度</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Sqlist</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="线性与非线性结构" tabindex="-1">线性与非线性结构 <a class="header-anchor" href="#线性与非线性结构" aria-label="Permalink to &quot;线性与非线性结构&quot;">​</a></h3><p>线性结构是一个有序数据元素的集合。常用的线性结构有：线性表，栈，队列，双队列，一维数组，串。</p><p>非线性结构，数学用语，其逻辑特征是一个结点元素可能有多个直接前趋和多个直接后继。常见的非线性结构有：二维数组，多维数组，广义表，树(二叉树等)。</p><p>传统文本（例如书籍中的文章和计算机的文本文件）都是线性结构，阅读是需要注意顺序阅读，而超文本则是一个非线性结构。在制作文本时，可将写作素材按内部联系划分成不同关系的单元，然后用制作工具将其组成一个网型结构。阅读时，不必按线性方式顺序往下读，而是有选择的阅读自己感兴趣的部分。</p><p>在超文本文件中，可以用一些单词，短语或图像作为连接点。这些连接点通常同其他颜色显示或加下划线来区分，这些形式的文件就成为超文本文件。通过非线性结构，可能实现页面任意跳转。</p><p>有一个以上根结点的数据结构一定是非线性结构。</p><h3 id="头指针与头结点" tabindex="-1">头指针与头结点 <a class="header-anchor" href="#头指针与头结点" aria-label="Permalink to &quot;头指针与头结点&quot;">​</a></h3><table><thead><tr><th>头指针</th><th>头结点</th></tr></thead><tbody><tr><td>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针</td><td>头结点是为了操作统一和方便设立的，放在第一元素的节点之前，其数据域一般无意义（也可存放链表长度）</td></tr><tr><td>头指针具有标识作用，所以长用头指针冠以链表的名字</td><td>有了头结点，对在第一元素的节点前插入节点和删除第一节点，其操作与其他节点的操作就统一了</td></tr><tr><td>无论链表表是否为空，头指针均不为空。头指针是链表的必要元素</td><td>头结点不一定是链表的必要元素</td></tr></tbody></table><h3 id="链表为空判断" tabindex="-1">链表为空判断 <a class="header-anchor" href="#链表为空判断" aria-label="Permalink to &quot;链表为空判断&quot;">​</a></h3><p>循环链表与单链表的判断主要差异就在于循环判断条件上：</p><ul><li>head-&gt;next = null , 单链表为空</li><li>head-&gt;next = head, 循环链表为空</li></ul><h3 id="链表的定义" tabindex="-1">链表的定义 <a class="header-anchor" href="#链表的定义" aria-label="Permalink to &quot;链表的定义&quot;">​</a></h3><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // C++中下面这个struct可以省略，因为C++中struct和class差不多</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // C中不可以省略，所以最好都带上</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Node</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> next;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="静态链表" tabindex="-1">静态链表 <a class="header-anchor" href="#静态链表" aria-label="Permalink to &quot;静态链表&quot;">​</a></h3><p>静态链表的实现原理是hash，即通过建立一个结构体数组，并令结构体数组的下标直接表示节点的地址，来达到通过直接访问数组中的元素达到访问节点的效果。另外，由于节点的访问非常方便，因此静态链表是不需要头结点的。</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 数据域</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> next;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 指针域，不再是结构体类型的指针</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div>`,20),l=[h];function e(p,k,d,r,c,o){return a(),i("div",null,l)}const y=s(n,[["render",e]]);export{g as __pageData,y as default};
