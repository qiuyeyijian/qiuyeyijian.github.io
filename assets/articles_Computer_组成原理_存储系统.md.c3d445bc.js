import{_ as a,o as e,c as r,U as t}from"./chunks/framework.adbdbaa5.js";const _=JSON.parse('{"title":"存储系统","description":"","frontmatter":{},"headers":[],"relativePath":"articles/Computer/组成原理/存储系统.md","filePath":"articles/Computer/组成原理/存储系统.md"}'),o={name:"articles/Computer/组成原理/存储系统.md"},l=t('<h1 id="存储系统" tabindex="-1">存储系统 <a class="header-anchor" href="#存储系统" aria-label="Permalink to &quot;存储系统&quot;">​</a></h1><h2 id="基础概念" tabindex="-1">基础概念 <a class="header-anchor" href="#基础概念" aria-label="Permalink to &quot;基础概念&quot;">​</a></h2><h3 id="存取时间" tabindex="-1">存取时间 <a class="header-anchor" href="#存取时间" aria-label="Permalink to &quot;存取时间&quot;">​</a></h3><p>执行一次读操作或写操作的时间，分读出时间和写入时间两种。</p><h3 id="存储周期" tabindex="-1">存储周期 <a class="header-anchor" href="#存储周期" aria-label="Permalink to &quot;存储周期&quot;">​</a></h3><p>存储器进行连续两次独立的读或写操作所需最小时间间隔，通常大于存取时间（因为包括了恢复时间）。</p><blockquote><p>注：存储周期直观理解就是，当启动某个存储体的后，只能等待一个存储周期后才能再次启动该存储体。</p></blockquote><h3 id="dram刷新" tabindex="-1">DRAM刷新 <a class="header-anchor" href="#dram刷新" aria-label="Permalink to &quot;DRAM刷新&quot;">​</a></h3><p>DRAM采用了地址复用技术。**刷新按行进行，每一行中的记忆单元同时被刷新，因此只需要行地址。**刷新的行号是由DRAM芯片的刷新控制电路中的刷新计数器产生。</p><p>**存储器的所有芯片的相同行同时进行刷新。**例如，有8个1024x1024x4位的DRAM芯片构成一个存储器，则只需要1024次刷新操作就可以把整个存储器刷新一遍。</p><h3 id="取指令缺失步骤" tabindex="-1">取指令缺失步骤 <a class="header-anchor" href="#取指令缺失步骤" aria-label="Permalink to &quot;取指令缺失步骤&quot;">​</a></h3><p>每条指令执行的第一步是取指令。若在Cache中取当前指令时发生缺失，则处理器必须按如下步骤完成：</p><ol><li>将程序计数器的内容恢复为当前指令的地址，并通过地址线送主存储器。</li><li>控制主存储器执行读操作（可能一次或多次），取出指令。对主存的访问要通过总线完成，一次总线事务完成一次读操作。</li><li>读出的指令写到Cache中，并把主存地址的高位写入Cache行的标记字段，最后设置有效位。</li><li>重新执行当前指令的第一步操作，即取指令，在Cache中命中。</li></ol><h3 id="逻辑地址到物理地址的转换" tabindex="-1">逻辑地址到物理地址的转换 <a class="header-anchor" href="#逻辑地址到物理地址的转换" aria-label="Permalink to &quot;逻辑地址到物理地址的转换&quot;">​</a></h3><p>如果采用动态重定位，则执行指令的过程中只要进行存储访问，总要先进性逻辑地址到物理地址的转换。逻辑地址到物理地址的转换由专门的硬件（存储管理单元MMU）实现。</p><p>如果采用静态重定位，则指令中的地址已经是物理地址，存储访问时不需要进行地址转换。逻辑地址到物理地址的转换由软件（链接程序或加载程序）实现。</p><h2 id="并行存储器结构技术" tabindex="-1">并行存储器结构技术 <a class="header-anchor" href="#并行存储器结构技术" aria-label="Permalink to &quot;并行存储器结构技术&quot;">​</a></h2><h3 id="双端口存储器" tabindex="-1">双端口存储器 <a class="header-anchor" href="#双端口存储器" aria-label="Permalink to &quot;双端口存储器&quot;">​</a></h3><h3 id="多模块存储器" tabindex="-1">多模块存储器 <a class="header-anchor" href="#多模块存储器" aria-label="Permalink to &quot;多模块存储器&quot;">​</a></h3><h4 id="连续编址" tabindex="-1">连续编址 <a class="header-anchor" href="#连续编址" aria-label="Permalink to &quot;连续编址&quot;">​</a></h4><p>主存地址的高位表示模块号，低位表示模块内地址</p><h4 id="交叉编址" tabindex="-1">交叉编址 <a class="header-anchor" href="#交叉编址" aria-label="Permalink to &quot;交叉编址&quot;">​</a></h4><p>主存地址的低位表示模块号，高位表示模块内地址。（有m个模块，则主存地址低 $log_2m$ 位表示模块号）。</p><p>交叉编址的多模块存储器可采用<strong>轮流启动</strong>或<strong>同时启动</strong>两种方式。</p><h5 id="轮流启动" tabindex="-1">轮流启动 <a class="header-anchor" href="#轮流启动" aria-label="Permalink to &quot;轮流启动&quot;">​</a></h5><p><strong>如果每个模块一次读写的位数（存储字长）正好等于系统总线中数据总线的位数，则采用轮流启动方式。</strong></p><p>按每隔1/m个存储周期轮流启动各个模块进行读写。这样每隔1/m个存储周期就可以读出或者写入一个数据，存取速度提高m倍。</p><h5 id="同时启动" tabindex="-1">同时启动 <a class="header-anchor" href="#同时启动" aria-label="Permalink to &quot;同时启动&quot;">​</a></h5><p><strong>如果所有存储模块一次并行读写的总位数正好等于系统总线中数据线数，则采用同时启动方式。</strong></p><p>例如，64M x 64位的主存是利用8个64M x 8位DRAM芯片进行位扩展而得到的，这样8个存储模块一共可提供64位，正好构成一个存储字，应该同时启动这8个模块进行并行访问。</p>',30),h=[l];function i(n,s,d,c,p,u){return e(),r("div",null,h)}const b=a(o,[["render",i]]);export{_ as __pageData,b as default};
